###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                10/Mar/2016  12:27:07
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoSensor.c
#    Command line       =  
#        -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0EEE
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoSensor.c
#        -D NWK_AUTO_POLL -D HOLD_AUTO_START -D POWER_SAVING -D NV_INIT -D
#        DEVICE_LOGICAL_TYPE=ZG_DEVICETYPE_ENDDEVICE -lC
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\SensorEB\List\
#        -lA
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\SensorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\SensorEB\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\Source\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Oh --require_prototypes
#    List file          =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\SensorEB\List\DemoSensor.lst
#    Object file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\SensorEB\Obj\DemoSensor.r51
#
###############################################################################

C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoSensor.c
      1          /**************************************************************************************************
      2            Filename:       DemoSensor.c
      3          
      4            Description:    Sensor application for the sensor demo utilizing the Simple API.
      5          
      6                            The sensor node is a ZigBee end device.
      7                            The sensor application binds to a gateway and will periodically
      8                            read temperature and supply voltage from the ADC and send report
      9                            towards the gateway node.
     10          
     11          
     12            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /******************************************************************************
     44           * INCLUDES
     45           */
     46          
     47          #include "ZComDef.h"
     48          #include "OSAL.h"
     49          #include "sapi.h"
     50          #include "hal_key.h"
     51          #include "hal_lcd.h"
     52          #include "hal_led.h"
     53          #include "hal_adc.h"
     54          #include "hal_mcu.h"
     55          #include "hal_uart.h"
     56          #include "DemoApp.h"
     57          
     58          /******************************************************************************
     59           * CONSTANTS
     60           */
     61          #define REPORT_FAILURE_LIMIT                4
     62          #define ACK_REQ_INTERVAL                    5 // each 5th packet is sent with ACK request
     63          
     64          // Application States
     65          #define APP_INIT                            0    // Initial state
     66          #define APP_START                           1    // Sensor has joined network
     67          #define APP_BIND                            2    // Sensor is in process of binding
     68          #define APP_REPORT                          4    // Sensor is in reporting state
     69          
     70          // Application osal event identifiers
     71          // Bit mask of events ( from 0x0000 to 0x00FF )
     72          #define MY_START_EVT                        0x0001
     73          #define MY_REPORT_EVT                       0x0002
     74          #define MY_FIND_COLLECTOR_EVT               0x0004
     75          
     76          // ADC definitions for CC2430/CC2530 from the hal_adc.c file
     77          #if defined (HAL_MCU_CC2530)
     78          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     79          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     80          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     81          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     82          #define HAL_ADC_CHN_VDD3    0x0f    /* Input channel: VDD/3 */
     83          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     84          #endif // HAL_MCU_CC2530
     85          
     86          /******************************************************************************
     87           * TYPEDEFS
     88           */
     89          
     90          /******************************************************************************
     91           * LOCAL VARIABLES
     92           */
     93          
     94          static uint8 appState =           APP_INIT;
     95          static uint8 reportState =        FALSE;
     96          
     97          static uint8 reportFailureNr =    0;
     98          
     99          static uint16 timeDone       =    0;
    100          static uint16 myReportPeriod =    50;        // milliseconds
    101          static uint16 myBindRetryDelay =  2000;        // milliseconds
    102          static uint8 myStartRetryDelay =    10;        // milliseconds
    103          static uint8 oldValue = 0;
    104          static uint16 parentShortAddr;
    105          
    106          /******************************************************************************
    107           * GLOBAL VARIABLES
    108           */
    109          
    110          // Inputs and Outputs for Sensor device
    111          #define NUM_OUT_CMD_SENSOR                1
    112          #define NUM_IN_CMD_SENSOR                 0
    113          
    114          // List of output and input commands for Sensor device
    115          const cId_t zb_OutCmdList[NUM_OUT_CMD_SENSOR] =
    116          {
    117            SENSOR_REPORT_CMD_ID
                   ^
Error[Pe020]: identifier "SENSOR_REPORT_CMD_ID" is undefined
    118          };
    119          
    120          // Define SimpleDescriptor for Sensor device
    121          const SimpleDescriptionFormat_t zb_SimpleDesc =
    122          {
    123            MY_ENDPOINT_ID,             //  Endpoint
    124            MY_PROFILE_ID,              //  Profile ID
    125            DEV_ID_SENSOR,              //  Device ID
    126            DEVICE_VERSION_SENSOR,      //  Device Version
    127            0,                          //  Reserved
    128            NUM_IN_CMD_SENSOR,          //  Number of Input Commands
    129            (cId_t *) NULL,             //  Input Command List
    130            NUM_OUT_CMD_SENSOR,         //  Number of Output Commands
    131            (cId_t *) zb_OutCmdList     //  Output Command List
    132          };
    133          
    134          /******************************************************************************
    135           * LOCAL FUNCTIONS
    136           */
    137          
    138          void uartRxCB( uint8 port, uint8 event );
    139          static void sendReport(void);
    140          static int8 readTemp(void);
    141          static uint8 readVoltage(void);
    142          
    143          /*****************************************************************************
    144           * @fn          zb_HandleOsalEvent
    145           *
    146           * @brief       The zb_HandleOsalEvent function is called by the operating
    147           *              system when a task event is set
    148           *
    149           * @param       event - Bitmask containing the events that have been set
    150           *
    151           * @return      none
    152           */
    153          void zb_HandleOsalEvent( uint16 event )
    154          {
    155            if( event & SYS_EVENT_MSG )
    156            {
    157            }
    158          
    159            if( event & ZB_ENTRY_EVENT )
    160            {
    161              // blind LED 1 to indicate joining a network
    162              HalLedBlink ( HAL_LED_1, 0, 50, 500 );
    163              // Set Pin Port to output
    164              MCU_IO_DIR_OUTPUT_PREP(0, 0);
    165              MCU_IO_OUTPUT_PREP(0, 0, 0);
    166              
    167              // Set Button
    168              MCU_IO_DIR_INPUT_PREP(0, 1);
    169              MCU_IO_INPUT_PREP(0,1,MCU_IO_PULLDOWN); 
    170              //MCU_IO_SET_HIGH(0, 1);
    171              // Start the device
    172              zb_StartRequest();
    173              
    174            }
    175          
    176            if ( event & MY_START_EVT )
    177            {
    178              zb_StartRequest();
    179            }
    180          
    181            if ( event & MY_REPORT_EVT )
    182            {
    183              if ( appState == APP_REPORT )
    184              {
    185                sendReport();
    186                osal_start_timerEx( sapi_TaskID, MY_REPORT_EVT, myReportPeriod );
    187              }
    188            }
    189          
    190            if ( event & MY_FIND_COLLECTOR_EVT )
    191            {
    192              // Delete previous binding
    193              if ( appState == APP_REPORT )
    194              {
    195                zb_BindDevice( FALSE, SENSOR_REPORT_CMD_ID, (uint8 *)NULL );
    196              }
    197          
    198              appState = APP_BIND;
    199              // blink LED 2 to indicate discovery and binding
    200              HalLedBlink ( HAL_LED_2, 0, 50, 500 );
    201          
    202              // Find and bind to a collector device
    203              zb_BindDevice( TRUE, SENSOR_REPORT_CMD_ID, (uint8 *)NULL );
    204            }
    205          }
    206          
    207          /******************************************************************************
    208           * @fn      zb_HandleKeys
    209           *
    210           * @brief   Handles all key events for this device.
    211           *
    212           * @param   shift - true if in shift/alt.
    213           * @param   keys - bit field for key events. Valid entries:
    214           *                 EVAL_SW4
    215           *                 EVAL_SW3
    216           *                 EVAL_SW2
    217           *                 EVAL_SW1
    218           *
    219           * @return  none
    220           */
    221          void zb_HandleKeys( uint8 shift, uint8 keys )
    222          {
    223            // Shift is used to make each button/switch dual purpose.
    224            if ( shift )
    225            {
    226              if ( keys & HAL_KEY_SW_1 )
    227              {
    228              }
    229              if ( keys & HAL_KEY_SW_2 )
    230              {
    231              }
    232              if ( keys & HAL_KEY_SW_3 )
    233              {
    234              }
    235              if ( keys & HAL_KEY_SW_4 )
    236              {
    237              }
    238            }
    239            else
    240            {
    241              if ( keys & HAL_KEY_SW_1 )
    242              {
    243                // Start reporting
    244                if ( reportState == FALSE ) {
    245                  osal_set_event( sapi_TaskID, MY_REPORT_EVT );
    246                  reportState = TRUE;
    247          
    248                  // blink LED 2 to indicate reporting
    249                  HalLedBlink ( HAL_LED_2, 0, 50, 500 );
    250                }
    251              }
    252              if ( keys & HAL_KEY_SW_2 )
    253              {
    254                MCU_IO_OUTPUT_PREP(0, 0, 1);
    255              }
    256              if ( keys & HAL_KEY_SW_3 )
    257              {
    258              }
    259              if ( keys & HAL_KEY_SW_4 )
    260              {
    261              }
    262            }
    263          }
    264          
    265          /******************************************************************************
    266           * @fn          zb_StartConfirm
    267           *
    268           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    269           *              after a start request operation completes
    270           *
    271           * @param       status - The status of the start operation.  Status of
    272           *                       ZB_SUCCESS indicates the start operation completed
    273           *                       successfully.  Else the status is an error code.
    274           *
    275           * @return      none
    276           */
    277          void zb_StartConfirm( uint8 status )
    278          {
    279            // If the device sucessfully started, change state to running
    280            if ( status == ZB_SUCCESS )
    281            {
    282              // Change application state
    283              appState = APP_START;
    284          
    285              // Set LED 1 to indicate that node is operational on the network
    286              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
    287          
    288              // Store parent short address
    289              zb_GetDeviceInfo(ZB_INFO_PARENT_SHORT_ADDR, &parentShortAddr);
    290          
    291              // Set event to bind to a collector
    292              osal_set_event( sapi_TaskID, MY_FIND_COLLECTOR_EVT );
    293              
    294          
    295            }
    296            else
    297            {
    298              // Try again later with a delay
    299              osal_start_timerEx( sapi_TaskID, MY_START_EVT, myStartRetryDelay );
    300            }
    301          }
    302          
    303          /******************************************************************************
    304           * @fn          zb_SendDataConfirm
    305           *
    306           * @brief       The zb_SendDataConfirm callback function is called by the
    307           *              ZigBee after a send data operation completes
    308           *
    309           * @param       handle - The handle identifying the data transmission.
    310           *              status - The status of the operation.
    311           *
    312           * @return      none
    313           */
    314          void zb_SendDataConfirm( uint8 handle, uint8 status )
    315          {
    316            if(status != ZB_SUCCESS)
    317            {
    318              if ( ++reportFailureNr >= REPORT_FAILURE_LIMIT )
    319              {
    320                 // Stop reporting
    321                 osal_stop_timerEx( sapi_TaskID, MY_REPORT_EVT );
    322          
    323                 // After failure start reporting automatically when the device
    324                 // is binded to a new gateway
    325                 reportState = TRUE;
    326          
    327                 // Try binding to a new gateway
    328                 osal_set_event( sapi_TaskID, MY_FIND_COLLECTOR_EVT );
    329                 reportFailureNr = 0;
    330              }
    331            }
    332            // status == SUCCESS
    333            else
    334            {
    335              // Reset failure counter
    336              reportFailureNr = 0;
    337            }
    338          }
    339          
    340          /******************************************************************************
    341           * @fn          zb_BindConfirm
    342           *
    343           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    344           *              after a bind operation completes.
    345           *
    346           * @param       commandId - The command ID of the binding being confirmed.
    347           *              status - The status of the bind operation.
    348           *
    349           * @return      none
    350           */
    351          void zb_BindConfirm( uint16 commandId, uint8 status )
    352          {
    353            if( status == ZB_SUCCESS )
    354            {
    355              appState = APP_REPORT;
    356              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
    357          
    358              // After failure reporting start automatically when the device
    359              // is binded to a new gateway
    360              if ( reportState )
    361              {
    362                // blink LED 2 to indicate reporting
    363                HalLedBlink ( HAL_LED_2, 0, 50, 500 );
    364          
    365                // Start reporting
    366                osal_set_event( sapi_TaskID, MY_REPORT_EVT );
    367              }
    368            }
    369            else
    370            {
    371              osal_start_timerEx( sapi_TaskID, MY_FIND_COLLECTOR_EVT, myBindRetryDelay );
    372            }
    373          }
    374          
    375          /******************************************************************************
    376           * @fn          zb_AllowBindConfirm
    377           *
    378           * @brief       Indicates when another device attempted to bind to this device
    379           *
    380           * @param
    381           *
    382           * @return      none
    383           */
    384          void zb_AllowBindConfirm( uint16 source )
    385          {
    386            (void)source;
    387          }
    388          
    389          /******************************************************************************
    390           * @fn          zb_FindDeviceConfirm
    391           *
    392           * @brief       The zb_FindDeviceConfirm callback function is called by the
    393           *              ZigBee stack when a find device operation completes.
    394           *
    395           * @param       searchType - The type of search that was performed.
    396           *              searchKey - Value that the search was executed on.
    397           *              result - The result of the search.
    398           *
    399           * @return      none
    400           */
    401          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
    402          {
    403            (void)searchType;
    404            (void)searchKey;
    405            (void)result;
    406          }
    407          
    408          /******************************************************************************
    409           * @fn          zb_ReceiveDataIndication
    410           *
    411           * @brief       The zb_ReceiveDataIndication callback function is called
    412           *              asynchronously by the ZigBee stack to notify the application
    413           *              when data is received from a peer device.
    414           *
    415           * @param       source - The short address of the peer device that sent the data
    416           *              command - The commandId associated with the data
    417           *              len - The number of bytes in the pData parameter
    418           *              pData - The data sent by the peer device
    419           *
    420           * @return      none
    421           */
    422          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
    423          {
    424            (void)source;
    425            (void)command;
    426            (void)len;
    427            (void)pData;
    428          }
    429          
    430          /******************************************************************************
    431           * @fn          uartRxCB
    432           *
    433           * @brief       Callback function for UART
    434           *
    435           * @param       port - UART port
    436           *              event - UART event that caused callback
    437           *
    438           * @return      none
    439           */
    440          void uartRxCB( uint8 port, uint8 event )
    441          {
    442            (void)port;
    443            (void)event;
    444          }
    445          
    446          /******************************************************************************
    447           * @fn          sendReport
    448           *
    449           * @brief       Send sensor report
    450           *
    451           * @param       none
    452           *
    453           * @return      none
    454           */
    455          static void sendReport(void)
    456          {
    457            uint8 pData[SENSOR_REPORT_LENGTH];
                               ^
Error[Pe020]: identifier "SENSOR_REPORT_LENGTH" is undefined
    458            static uint8 reportNr = 0;
    459            uint8 txOptions;
    460          
    461            // Read and report temperature value
    462            pData[SENSOR_TEMP_OFFSET] = readTemp();
                         ^
Error[Pe020]: identifier "SENSOR_TEMP_OFFSET" is undefined
    463          
    464            // Read and report voltage value
    465            pData[SENSOR_VOLTAGE_OFFSET] = readVoltage();
                         ^
Error[Pe020]: identifier "SENSOR_VOLTAGE_OFFSET" is undefined
    466          
    467            pData[SENSOR_PARENT_OFFSET] =  HI_UINT16(parentShortAddr);
                         ^
Error[Pe020]: identifier "SENSOR_PARENT_OFFSET" is undefined
    468            pData[SENSOR_PARENT_OFFSET + 1] =  LO_UINT16(parentShortAddr);
    469            pData[BUTTON_PARENT_OFFSET+1] = MCU_IO_GET(0,1);
                         ^
Error[Pe020]: identifier "BUTTON_PARENT_OFFSET" is undefined
    470           // HalUARTWrite(HAL_UART_PORT_0,pData,SENSOR_REPORT_LENGTH);
    471           // HalUARTWrite(HAL_UART_PORT_1,pData,SENSOR_REPORT_LENGTH);
    472            int test = MCU_IO_GET(0,1);
    473            if( MCU_IO_GET(0,1) > 0){
    474              MCU_IO_SET_LOW(0, 0);
    475            } else {
    476              MCU_IO_SET_HIGH(0, 0);
    477            }
    478            MCU_IO_SET_LOW(0, 1);
    479            // Set ACK request on each ACK_INTERVAL report
    480            // If a report failed, set ACK request on next report
    481            if ( ++reportNr<ACK_REQ_INTERVAL && reportFailureNr == 0 )
    482            {
    483              txOptions = AF_TX_OPTIONS_NONE;
    484            }
    485            else
    486            {
    487              txOptions = AF_MSG_ACK_REQUEST;
    488              reportNr = 0;
    489            }
    490            // Destination address 0xFFFE: Destination address is sent to previously
    491            // established binding for the commandId.
    492            //printf("%i %i",pData[SENSOR_TEMP_OFFSET],oldValue);
    493            if(timeDone >= 60000){
    494               timeDone += 1;
    495            }
    496            if(pData[SENSOR_TEMP_OFFSET] != oldValue && timeDone >= 60000){
    497              oldValue = pData[SENSOR_TEMP_OFFSET];
    498              zb_SendDataRequest( 0xFFFE, SENSOR_REPORT_CMD_ID, SENSOR_REPORT_LENGTH, pData, 0, txOptions, 0 );
    499              timeDone = 0;
    500            } else {
    501              timeDone += myReportPeriod;
    502            }
    503          }
    504          /******************************************************************************
    505           * @fn          readTemp
    506           *
    507           * @brief       read temperature from ADC
    508           *
    509           * @param       none
    510           *
    511           * @return      temperature
    512           */
    513          static int8 readTemp(void)
    514          {
    515            static uint16 voltageAtTemp22;
    516            static uint8 bCalibrate = TRUE; // Calibrate the first time the temp sensor is read
    517            uint16 value;
    518            int8 temp;
    519          
    520            #if defined (HAL_MCU_CC2530)
    521            /*
    522             * Use the ADC to read the temperature
    523             */
    524            value = HalReadTemp();
    525          
    526            // Use the 12 MSB of adcValue
    527            value >>= 4;
    528          
    529            /*
    530             * These parameters are typical values and need to be calibrated
    531             * See the datasheet for the appropriate chip for more details
    532             * also, the math below may not be very accurate
    533             */
    534            /* Assume ADC = 1480 at 25C and ADC = 4/C */
    535            #define VOLTAGE_AT_TEMP_25        1480
    536            #define TEMP_COEFFICIENT          4
    537          
    538            // Calibrate for 22C the first time the temp sensor is read.
    539            // This will assume that the demo is started up in temperature of 22C
    540            if ( bCalibrate ) {
    541              voltageAtTemp22 = value;
    542              bCalibrate = FALSE;
    543            }
    544          
    545            temp = 22 + ( (value - voltageAtTemp22) / TEMP_COEFFICIENT );
    546          
    547            // Set 0C as minimum temperature, and 100C as max
    548            if ( temp >= 100 )
    549            {
    550              return 100;
    551            }
    552            else if ( temp <= 0 ) {
    553              return 0;
    554            }
    555            else {
    556              return temp;
    557            }
    558            // Only CC2530 is supported
    559            #else
    560            return 0;
    561            #endif
    562          }
    563          
    564          /******************************************************************************
    565           * @fn          readVoltage
    566           *
    567           * @brief       read voltage from ADC
    568           *
    569           * @param       none
    570           *
    571           * @return      voltage
    572           */
    573          static uint8 readVoltage(void)
    574          {
    575            #if defined (HAL_MCU_CC2530)
    576            /*
    577             * Use the ADC to read the bus voltage
    578             */
    579            uint16 value = HalReadTemp();
    580          
    581            // value now contains measurement of Vdd/3
    582            // 0 indicates 0V and 32767 indicates 1.25V
    583            // voltage = (value*3*1.25)/32767 volts
    584            // we will multiply by this by 10 to allow units of 0.1 volts
    585            value = value >> 6;   // divide first by 2^6
    586            value = (uint16)(value * 37.5);
    587            value = value >> 9;   // ...and later by 2^9...to prevent overflow during multiplication
    588          
    589            return value;
    590            #else
    591            return 0;
    592            #endif // CC2530
    593          }

Errors: 6
Warnings: none
