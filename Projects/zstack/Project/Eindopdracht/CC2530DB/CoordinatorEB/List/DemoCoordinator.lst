###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                14/Mar/2016  21:05:54
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
#    Command line       =  
#        -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0EEE
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        xNV_RESTORE -D ZTOOL_P1 -lC
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\
#        -lA
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\Source\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Oh --require_prototypes
#    List file          =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\DemoCoordinator.lst
#    Object file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\Obj\DemoCoordinator.r51
#
###############################################################################

C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
      1          /**************************************************************************************************
      2            Filename:       DemoCoordinator.c
      3          
      4            Description:    Coordinator application for the sensor demo utilizing Simple API.
      5          
      6                            The collector node can be set in a state where it accepts
      7                            incoming reports from the sensor nodes, and can send the reports
      8                            via the UART to a PC tool. The collector node in this state
      9                            functions as a gateway. The collector nodes that are not in the
     10                            gateway node function as routers in the network.
     11          
     12          
     13            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15            IMPORTANT: Your use of this Software is limited to those specific rights
     16            granted under the terms of a software license agreement between the user
     17            who downloaded the software, his/her employer (which must be your employer)
     18            and Texas Instruments Incorporated (the "License").  You may not use this
     19            Software unless you agree to abide by the terms of the License. The License
     20            limits your use, and you acknowledge, that the Software may not be modified,
     21            copied or distributed unless embedded on a Texas Instruments microcontroller
     22            or used solely and exclusively in conjunction with a Texas Instruments radio
     23            frequency transceiver, which is integrated into your product.  Other than for
     24            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25            works of, modify, distribute, perform, display or sell this Software and/or
     26            its documentation for any purpose.
     27          
     28            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40            Should you have any questions regarding your right to use this Software,
     41            contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /******************************************************************************
     45           * INCLUDES
     46           */
     47          
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "sapi.h"
     52          #include "hal_key.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     53          #include "hal_led.h"
     54          #include "hal_lcd.h"
     55          #include "hal_uart.h"
     56          #include "DemoApp.h"
     57          
     58          /******************************************************************************
     59           * CONSTANTS
     60           */
     61          
     62          // General UART frame offsets
     63          #define FRAME_SOF_OFFSET                    0
     64          #define FRAME_LENGTH_OFFSET                 1
     65          #define FRAME_CMD0_OFFSET                   2
     66          #define FRAME_CMD1_OFFSET                   3
     67          #define FRAME_DATA_OFFSET                   4
     68          
     69          // ZB_RECEIVE_DATA_INDICATION offsets
     70          #define ZB_RECV_SRC_OFFSET                  0
     71          #define ZB_RECV_CMD_OFFSET                  2
     72          #define ZB_RECV_LEN_OFFSET                  4
     73          #define ZB_RECV_DATA_OFFSET                 6
     74          #define ZB_RECV_FCS_OFFSET                  8
     75          
     76          // ZB_RECEIVE_DATA_INDICATION frame length
     77          #define ZB_RECV_LENGTH                      15
     78          
     79          // PING response frame length and offset
     80          #define SYS_PING_RSP_LENGTH                 7
     81          #define SYS_PING_CMD_OFFSET                 1
     82          
     83          // Stack Profile
     84          #define ZIGBEE_2007                         0x0040
     85          #define ZIGBEE_PRO_2007                     0x0041
     86          
     87          #ifdef ZIGBEEPRO
     88          #define STACK_PROFILE                       ZIGBEE_PRO_2007
     89          #else
     90          #define STACK_PROFILE                       ZIGBEE_2007
     91          #endif
     92          
     93          #define CPT_SOP                             0xFE
     94          #define SYS_PING_REQUEST                    0x0021
     95          #define SYS_PING_RESPONSE                   0x0161
     96          #define ZB_RECEIVE_DATA_INDICATION          0x8746
     97          
     98          // Application States
     99          #define APP_INIT                            0
    100          #define APP_START                           2
    101          
    102          // Application osal event identifiers
    103          #define MY_START_EVT                        0x0001
    104          #define LOCK_CHECK_EVT                       0x0002
    105          
    106          /******************************************************************************
    107           * TYPEDEFS
    108           */
    109          typedef struct
    110          {
    111            uint16              source;
    112            uint16              parent;
    113            uint8               temp;
    114            uint8               voltage;
    115          } gtwData_t;
    116          
    117          /******************************************************************************
    118           * LOCAL VARIABLES
    119           */
    120          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    121          static uint8 appState =             APP_INIT;
   \                     appState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    122          static uint8 myStartRetryDelay =    10;          // milliseconds
   \                     myStartRetryDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for myStartRetryDelay>`
   \   000001                REQUIRE __INIT_XDATA_I
    123          static gtwData_t gtwData;

   \                                 In  segment XDATA_I, align 1, keep-with-next
    124          static uint8 doorState         =        DOOR_OPEN;
   \                     doorState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for doorState>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    125          static uint8 buttonState       =        0;
   \                     buttonState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    126          /******************************************************************************
    127           * LOCAL FUNCTIONS
    128           */
    129          
    130          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    131          static void sysPingReqRcvd(void);
    132          static void sysPingRsp(void);
    133          static void sendGtwReport(gtwData_t *gtwData);
    134          
    135          /******************************************************************************
    136           * GLOBAL VARIABLES
    137           */
    138          
    139          // Inputs and Outputs for Collector device
    140          #define NUM_OUT_CMD_COLLECTOR           2
    141          #define NUM_IN_CMD_COLLECTOR            2
    142          
    143          // List of output and input commands for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    144          const cId_t zb_InCmdList[NUM_IN_CMD_COLLECTOR] =
   \                     zb_InCmdList:
   \   000000   0100         DW 1
   \   000002   0200         DW 2
    145          {
    146            LOCK_CONTROL_CMD_ID,
    147            LIGHT_CONTROL_CMD_ID
    148          };

   \                                 In  segment XDATA_ROM_C, align 1
    149          const cId_t zb_OutCmdList[NUM_OUT_CMD_COLLECTOR] =
   \                     zb_OutCmdList:
   \   000000   0300         DW 3
   \   000002   0400         DW 4
    150          {
    151            LOCK_STATUS_CMD_ID,
    152            LIGHT_STATUS_CMD_ID
    153          };
    154          
    155          
    156          // Define SimpleDescriptor for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    157          const SimpleDescriptionFormat_t zb_SimpleDesc =
   \                     zb_SimpleDesc:
   \   000000   02           DB 2
   \   000001   200F         DW 3872
   \   000003   0200         DW 2
   \   000005   01           DB 1
   \   000006   02           DB 2
   \   000007   ....         DW zb_InCmdList
   \   000009   02           DB 2
   \   00000A   ....         DW zb_OutCmdList
    158          {
    159            MY_ENDPOINT_ID,             //  Endpoint
    160            MY_PROFILE_ID,              //  Profile ID
    161            DEV_ID_COLLECTOR,           //  Device ID
    162            DEVICE_VERSION_COLLECTOR,   //  Device Version
    163            0,                          //  Reserved
    164            NUM_IN_CMD_COLLECTOR,       //  Number of Input Commands
    165            (cId_t *) zb_InCmdList,     //  Input Command List
    166            NUM_OUT_CMD_COLLECTOR,      //  Number of Output Commands
    167            (cId_t *) zb_OutCmdList             //  Output Command List
    168          };
    169          
    170          /******************************************************************************
    171           * FUNCTIONS
    172           */
    173          
    174          /******************************************************************************
    175           * @fn          zb_HandleOsalEvent
    176           *
    177           * @brief       The zb_HandleOsalEvent function is called by the operating
    178           *              system when a task event is set
    179           *
    180           * @param       event - Bitmask containing the events that have been set
    181           *
    182           * @return      none
    183           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    184          void zb_HandleOsalEvent( uint16 event )
   \                     zb_HandleOsalEvent:
    185          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
    186            if( event & SYS_EVENT_MSG )
    187            {
    188            }
    189          
    190            if( event & ZB_ENTRY_EVENT )
   \   00000D   5410         ANL     A,#0x10
   \   00000F   6021         JZ      ??zb_HandleOsalEvent_0
    191            {
    192              // Initialise UART
    193              initUart(uartRxCB);
   \   000011                ; Setup parameters for call to function initUart
   \   000011   7A..         MOV     R2,#`??uartRxCB::?relay` & 0xff
   \   000013   7B..         MOV     R3,#(`??uartRxCB::?relay` >> 8) & 0xff
   \   000015   12....       LCALL   `??initUart::?relay` ; Banked call to: initUart
    194              osal_start_timerEx( sapi_TaskID, LOCK_CHECK_EVT , 100 );
   \   000018                ; Setup parameters for call to function osal_start_timerEx
   \   000018   90....       MOV     DPTR,#__Constant_64
   \   00001B   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   00001E   7A02         MOV     R2,#0x2
   \   000020   7B00         MOV     R3,#0x0
   \   000022   90....       MOV     DPTR,#sapi_TaskID
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00002A   7404         MOV     A,#0x4
   \   00002C   12....       LCALL   ?DEALLOC_XSTACK8
    195          
    196              
    197              // Start the device
    198              zb_StartRequest();
   \   00002F                ; Setup parameters for call to function zb_StartRequest
   \   00002F   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    199            }
    200          
    201            if ( event & MY_START_EVT )
   \                     ??zb_HandleOsalEvent_0:
   \   000032   EE           MOV     A,R6
   \   000033   A2E0         MOV     C,0xE0 /* A   */.0
   \   000035   5003         JNC     ??zb_HandleOsalEvent_1
    202            {
    203              zb_StartRequest();
   \   000037                ; Setup parameters for call to function zb_StartRequest
   \   000037   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    204            }
    205            if (event & LOCK_CHECK_EVT ){
   \                     ??zb_HandleOsalEvent_1:
   \   00003A   EE           MOV     A,R6
   \   00003B   5402         ANL     A,#0x2
   \   00003D   6072         JZ      ??zb_HandleOsalEvent_2
    206                  int buttonStateNew = (MCU_IO_GET(0,2) == 0);
   \   00003F   A282         MOV     C,0x80.2
   \   000041   4004         JC      ??zb_HandleOsalEvent_3
   \   000043   D2F0         SETB    B.0
   \   000045   8002         SJMP    ??zb_HandleOsalEvent_4
   \                     ??zb_HandleOsalEvent_3:
   \   000047   C2F0         CLR     B.0
   \                     ??zb_HandleOsalEvent_4:
   \   000049   A2F0         MOV     C,B.0
   \   00004B   E4           CLR     A
   \   00004C   33           RLC     A
   \   00004D   FE           MOV     R6,A
    207                  if (buttonState != buttonStateNew){
   \   00004E   90....       MOV     DPTR,#buttonState
   \   000051   E0           MOVX    A,@DPTR
   \   000052   C0E0         PUSH    A
   \   000054   EE           MOV     A,R6
   \   000055   F8           MOV     R0,A
   \   000056   D0E0         POP     A
   \   000058   68           XRL     A,R0
   \   000059   603F         JZ      ??zb_HandleOsalEvent_5
    208                    uint8 pData[LOCK_CMD_LENGTH];
    209                    pData[LOCK_CMD_OFFSET] = buttonStateNew;
   \   00005B   EE           MOV     A,R6
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   F0           MOVX    @DPTR,A
    210                    uint8 txOptions;
    211                    zb_SendDataRequest( 0xFFFE, LOCK_STATUS_CMD_ID, LOCK_CMD_LENGTH , pData, 0, txOptions, 0 );
                                                                                                       ^
Warning[Pe549]: variable "txOptions" is used before its value is set

  static uint8 appState =             APP_INIT;
               ^
"C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c",121  Warning[Pe550]: 
          variable "appState" was set but never used

  static gtwData_t gtwData;
                   ^
"C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c",123  Warning[Pe177]: 
          variable "gtwData" was declared but never referenced
   \   000063                ; Setup parameters for call to function zb_SendDataRequest
   \   000063   75..00       MOV     ?V0,#0x0
   \   000066   78..         MOV     R0,#?V0
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006B   78..         MOV     R0,#?V0
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000070   78..         MOV     R0,#?V0
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000075   7403         MOV     A,#0x3
   \   000077   12....       LCALL   ?XSTACK_DISP100_8
   \   00007A   88..         MOV     ?V0,R0
   \   00007C   89..         MOV     ?V1,R1
   \   00007E   78..         MOV     R0,#?V0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000083   7901         MOV     R1,#0x1
   \   000085   7C03         MOV     R4,#0x3
   \   000087   7D00         MOV     R5,#0x0
   \   000089   7AFE         MOV     R2,#-0x2
   \   00008B   7BFF         MOV     R3,#-0x1
   \   00008D   12....       LCALL   `??zb_SendDataRequest::?relay`; Banked call to: zb_SendDataRequest
   \   000090   7405         MOV     A,#0x5
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
    212                    buttonState = buttonStateNew;
   \   000095   EE           MOV     A,R6
   \   000096   90....       MOV     DPTR,#buttonState
   \   000099   F0           MOVX    @DPTR,A
    213                  }
    214                  osal_start_timerEx( sapi_TaskID, LOCK_CHECK_EVT , 100 );
   \                     ??zb_HandleOsalEvent_5:
   \   00009A                ; Setup parameters for call to function osal_start_timerEx
   \   00009A   90....       MOV     DPTR,#__Constant_64
   \   00009D   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000A0   7A02         MOV     R2,#0x2
   \   0000A2   7B00         MOV     R3,#0x0
   \   0000A4   90....       MOV     DPTR,#sapi_TaskID
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F9           MOV     R1,A
   \   0000A9   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0000AC   7404         MOV     A,#0x4
   \   0000AE   12....       LCALL   ?DEALLOC_XSTACK8
    215            }
    216          }
   \                     ??zb_HandleOsalEvent_2:
   \   0000B1   7401         MOV     A,#0x1
   \   0000B3                REQUIRE ?Subroutine0
   \   0000B3                REQUIRE _A_P0
   \   0000B3                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F02         MOV     R7,#0x2
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    217          
    218          /******************************************************************************
    219           * @fn      zb_HandleKeys
    220           *
    221           * @brief   Handles all key events for this device.
    222           *
    223           * @param   shift - true if in shift/alt.
    224           * @param   keys - bit field for key events. Valid entries:
    225           *                 EVAL_SW4
    226           *                 EVAL_SW3
    227           *                 EVAL_SW2
    228           *                 EVAL_SW1
    229           *
    230           * @return  none
    231           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    232          void zb_HandleKeys( uint8 shift, uint8 keys )
   \                     zb_HandleKeys:
    233          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    234            // Shift is used to make each button/switch dual purpose.
    235            if ( shift )
    236            {
    237              if ( keys & HAL_KEY_SW_1 )
    238              {
    239              }
    240              if ( keys & HAL_KEY_SW_2 )
    241              {
    242              }
    243              if ( keys & HAL_KEY_SW_3 )
    244              {
    245              }
    246              if ( keys & HAL_KEY_SW_4 )
    247              {
    248              }
    249            }
    250            else
    251            {
    252              if ( keys & HAL_KEY_SW_1 )
    253              {
    254              }
    255              if ( keys & HAL_KEY_SW_2 )
    256              {
    257              }
    258              if ( keys & HAL_KEY_SW_3 )
    259              {
    260              }
    261              if ( keys & HAL_KEY_SW_4 )
    262              {
    263              }
    264            }
    265          }
   \   000000   02....       LJMP    ?BRET
    266          
    267          /******************************************************************************
    268           * @fn          zb_StartConfirm
    269           *
    270           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    271           *              after a start request operation completes
    272           *
    273           * @param       status - The status of the start operation.  Status of
    274           *                       ZB_SUCCESS indicates the start operation completed
    275           *                       successfully.  Else the status is an error code.
    276           *
    277           * @return      none
    278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    279          void zb_StartConfirm( uint8 status )
   \                     zb_StartConfirm:
    280          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    281            
    282            
    283            // If the device sucessfully started, change state to running
    284            if ( status == ZB_SUCCESS )
   \   000006   7047         JNZ     ??zb_StartConfirm_0
    285            {
    286              // Change application state
    287              appState = APP_START;
   \   000008   90....       MOV     DPTR,#appState
   \   00000B   7402         MOV     A,#0x2
   \   00000D   F0           MOVX    @DPTR,A
    288              
    289              MCU_IO_DIR_OUTPUT_PREP(0, 4);
   \   00000E   43FD10       ORL     0xfd,#0x10
    290              MCU_IO_DIR_OUTPUT_PREP(0, 7);
   \   000011   43FD80       ORL     0xfd,#0x80
    291              MCU_IO_DIR_INPUT_PREP(0, 2);
   \   000014   53FDFB       ANL     0xfd,#0xfb
    292              MCU_IO_INPUT_PREP(0,2,MCU_IO_PULLDOWN); 
   \   000017   53F3FB       ANL     0xf3,#0xfb
   \   00001A   53FDFB       ANL     0xfd,#0xfb
   \   00001D   538FFB       ANL     0x8f,#0xfb
   \   000020   43F720       ORL     0xf7,#0x20
    293              MCU_IO_OUTPUT_PREP(0, 4, 0);
   \   000023   53F3EF       ANL     0xf3,#0xef
   \   000026   C284         CLR     0x80.4
   \   000028   43FD10       ORL     0xfd,#0x10
    294              MCU_IO_OUTPUT_PREP(0, 7, DOOR_OPEN);
   \   00002B   53F37F       ANL     0xf3,#0x7f
   \   00002E   D287         SETB    0x80.7
   \   000030   43FD80       ORL     0xfd,#0x80
    295              
    296              zb_AllowBind( 0xFF );
   \   000033                ; Setup parameters for call to function zb_AllowBind
   \   000033   79FF         MOV     R1,#-0x1
   \   000035   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    297              
    298              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
   \   000038                ; Setup parameters for call to function HalLedSet
   \   000038   7A01         MOV     R2,#0x1
   \   00003A   7901         MOV     R1,#0x1
   \   00003C   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    299              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   00003F                ; Setup parameters for call to function HalLedSet
   \   00003F   7A00         MOV     R2,#0x0
   \   000041   7902         MOV     R1,#0x2
   \   000043   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    300              HalLedSet( HAL_LED_3, HAL_LED_MODE_OFF );
   \   000046                ; Setup parameters for call to function HalLedSet
   \   000046   7A00         MOV     R2,#0x0
   \   000048   7904         MOV     R1,#0x4
   \   00004A   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   00004D   8023         SJMP    ??zb_StartConfirm_1
    301            }
    302            else
    303            {
    304              // Try again later with a delay
    305              osal_start_timerEx( sapi_TaskID, MY_START_EVT, myStartRetryDelay );
   \                     ??zb_StartConfirm_0:
   \   00004F                ; Setup parameters for call to function osal_start_timerEx
   \   00004F   90....       MOV     DPTR,#myStartRetryDelay
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5..         MOV     ?V0,A
   \   000055   E4           CLR     A
   \   000056   F5..         MOV     ?V1,A
   \   000058   F5..         MOV     ?V2,A
   \   00005A   F5..         MOV     ?V3,A
   \   00005C   78..         MOV     R0,#?V0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000061   7A01         MOV     R2,#0x1
   \   000063   7B00         MOV     R3,#0x0
   \   000065   90....       MOV     DPTR,#sapi_TaskID
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F9           MOV     R1,A
   \   00006A   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00006D   7404         MOV     A,#0x4
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
    306            }
    307          }
   \                     ??zb_StartConfirm_1:
   \   000072   7F04         MOV     R7,#0x4
   \   000074   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000077                REQUIRE P0DIR
   \   000077                REQUIRE P0SEL
   \   000077                REQUIRE P0INP
   \   000077                REQUIRE P2INP
   \   000077                REQUIRE _A_P0
    308          
    309          /******************************************************************************
    310           * @fn          zb_SendDataConfirm
    311           *
    312           * @brief       The zb_SendDataConfirm callback function is called by the
    313           *              ZigBee stack after a send data operation completes
    314           *
    315           * @param       handle - The handle identifying the data transmission.
    316           *              status - The status of the operation.
    317           *
    318           * @return      none
    319           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    320          void zb_SendDataConfirm( uint8 handle, uint8 status )
   \                     zb_SendDataConfirm:
    321          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    322            if (status == ZB_SUCCESS){
    323              
    324            
    325            }
    326          }
   \   000000   02....       LJMP    ?BRET
    327          
    328          /******************************************************************************
    329           * @fn          zb_BindConfirm
    330           *
    331           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    332           *              after a bind operation completes.
    333           *
    334           * @param       commandId - The command ID of the binding being confirmed.
    335           *              status - The status of the bind operation.
    336           *
    337           * @return      none
    338           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    339          void zb_BindConfirm( uint16 commandId, uint8 status )
   \                     zb_BindConfirm:
    340          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0,R1
    341            zb_AllowBind( 0xFF );
   \   00000B                ; Setup parameters for call to function zb_AllowBind
   \   00000B   79FF         MOV     R1,#-0x1
   \   00000D   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    342            
    343            if (status == ZB_SUCCESS){
   \   000010   E5..         MOV     A,?V0
   \   000012   7021         JNZ     ??zb_BindConfirm_0
    344              if(commandId == LOCK_STATUS_CMD_ID){
   \   000014   7403         MOV     A,#0x3
   \   000016   6E           XRL     A,R6
   \   000017   4F           ORL     A,R7
   \   000018   700E         JNZ     ??zb_BindConfirm_1
    345                MCU_IO_OUTPUT_PREP(0, 4, 1);
   \   00001A   53F3EF       ANL     0xf3,#0xef
   \   00001D   D284         SETB    0x80.4
   \   00001F   43FD10       ORL     0xfd,#0x10
    346                HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON);
   \   000022                ; Setup parameters for call to function HalLedSet
   \   000022   7A01         MOV     R2,#0x1
   \   000024   7902         MOV     R1,#0x2
   \   000026   800A         SJMP    ??zb_BindConfirm_2
    347              }
    348              else if(commandId == LIGHT_STATUS_CMD_ID){
   \                     ??zb_BindConfirm_1:
   \   000028   7404         MOV     A,#0x4
   \   00002A   6E           XRL     A,R6
   \   00002B   4F           ORL     A,R7
   \   00002C   7007         JNZ     ??zb_BindConfirm_0
    349                HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON);
   \   00002E                ; Setup parameters for call to function HalLedSet
   \   00002E   7A01         MOV     R2,#0x1
   \   000030   7904         MOV     R1,#0x4
   \                     ??zb_BindConfirm_2:
   \   000032   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    350              }
    351            }
    352            
    353          }
   \                     ??zb_BindConfirm_0:
   \   000035   7F01         MOV     R7,#0x1
   \   000037   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00003A                REQUIRE P0SEL
   \   00003A                REQUIRE _A_P0
   \   00003A                REQUIRE P0DIR
    354          
    355          /******************************************************************************
    356           * @fn          zb_AllowBindConfirm
    357           *
    358           * @brief       Indicates when another device attempted to bind to this device
    359           *
    360           * @param
    361           *
    362           * @return      none
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          void zb_AllowBindConfirm( uint16 source )
   \                     zb_AllowBindConfirm:
    365          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    366            
    367          }
   \   000000   02....       LJMP    ?BRET
    368          
    369          /******************************************************************************
    370           * @fn          zb_FindDeviceConfirm
    371           *
    372           * @brief       The zb_FindDeviceConfirm callback function is called by the
    373           *              ZigBee stack when a find device operation completes.
    374           *
    375           * @param       searchType - The type of search that was performed.
    376           *              searchKey - Value that the search was executed on.
    377           *              result - The result of the search.
    378           *
    379           * @return      none
    380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    381          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
   \                     zb_FindDeviceConfirm:
    382          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    383            (void)searchType;
    384            (void)searchKey;
    385            (void)result;
    386          }
   \   000000   02....       LJMP    ?BRET
    387          
    388          /******************************************************************************
    389           * @fn          zb_ReceiveDataIndication
    390           *
    391           * @brief       The zb_ReceiveDataIndication callback function is called
    392           *              asynchronously by the ZigBee stack to notify the application
    393           *              when data is received from a peer device.
    394           *
    395           * @param       source - The short address of the peer device that sent the data
    396           *              command - The commandId associated with the data
    397           *              len - The number of bytes in the pData parameter
    398           *              pData - The data sent by the peer device
    399           *
    400           * @return      none
    401           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    402          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
    403          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   7402         MOV     A,#0x2
   \   000006   12....       LCALL   ?XSTACK_DISP0_8
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   8882         MOV     DPL,R0
   \   000010   8983         MOV     DPH,R1
    404            if(command == LOCK_CONTROL_CMD_ID){
   \   000012   7401         MOV     A,#0x1
   \   000014   6C           XRL     A,R4
   \   000015   4D           ORL     A,R5
   \   000016   702F         JNZ     ??zb_ReceiveDataIndication_0
    405              if(*pData == IDENTIFIER_COMMAND ){
   \   000018   E0           MOVX    A,@DPTR
   \   000019   64F0         XRL     A,#0xf0
   \   00001B   700D         JNZ     ??zb_ReceiveDataIndication_1
    406                zb_AllowBind( 0x00 );
   \   00001D                ; Setup parameters for call to function zb_AllowBind
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    407                zb_BindDevice( TRUE, LOCK_STATUS_CMD_ID, (uint8 *)NULL) ;
   \   000022                ; Setup parameters for call to function zb_BindDevice
   \   000022   7C00         MOV     R4,#0x0
   \   000024   7D00         MOV     R5,#0x0
   \   000026   7A03         MOV     R2,#0x3
   \   000028   8033         SJMP    ??zb_ReceiveDataIndication_2
    408              }
    409              else{
    410                if( doorState == DOOR_OPEN){
   \                     ??zb_ReceiveDataIndication_1:
   \   00002A   90....       MOV     DPTR,#doorState
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6401         XRL     A,#0x1
   \   000030   53F37F       ANL     0xf3,#0x7f
   \   000033   7008         JNZ     ??zb_ReceiveDataIndication_3
    411                   //MCU_IO_OUTPUT_PREP(0, 4, 1);
    412                   MCU_IO_OUTPUT_PREP(0, 7, 0);
   \   000035   C287         CLR     0x80.7
   \   000037   43FD80       ORL     0xfd,#0x80
    413                   doorState = DOOR_CLOSE;
   \   00003A   E4           CLR     A
   \   00003B   8007         SJMP    ??zb_ReceiveDataIndication_4
    414                } else {
    415                   //MCU_IO_OUTPUT_PREP(0, 4, 0);
    416                   MCU_IO_OUTPUT_PREP(0, 7, 1);
   \                     ??zb_ReceiveDataIndication_3:
   \   00003D   D287         SETB    0x80.7
   \   00003F   43FD80       ORL     0xfd,#0x80
    417                   doorState = DOOR_OPEN;
   \   000042   7401         MOV     A,#0x1
   \                     ??zb_ReceiveDataIndication_4:
   \   000044   F0           MOVX    @DPTR,A
   \   000045   801D         SJMP    ??zb_ReceiveDataIndication_5
    418                }
    419              }
    420            }
    421            
    422            else if(command == LIGHT_CONTROL_CMD_ID){
   \                     ??zb_ReceiveDataIndication_0:
   \   000047   7402         MOV     A,#0x2
   \   000049   6C           XRL     A,R4
   \   00004A   4D           ORL     A,R5
   \   00004B   7017         JNZ     ??zb_ReceiveDataIndication_5
    423              if(*pData == IDENTIFIER_COMMAND ){
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   64F0         XRL     A,#0xf0
   \   000050   7012         JNZ     ??zb_ReceiveDataIndication_5
    424                zb_AllowBind( 0x00 );
   \   000052                ; Setup parameters for call to function zb_AllowBind
   \   000052   7900         MOV     R1,#0x0
   \   000054   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    425                zb_BindDevice( TRUE, LIGHT_STATUS_CMD_ID, (uint8 *)NULL) ;
   \   000057                ; Setup parameters for call to function zb_BindDevice
   \   000057   7C00         MOV     R4,#0x0
   \   000059   7D00         MOV     R5,#0x0
   \   00005B   7A04         MOV     R2,#0x4
   \                     ??zb_ReceiveDataIndication_2:
   \   00005D   7B00         MOV     R3,#0x0
   \   00005F   7901         MOV     R1,#0x1
   \   000061   12....       LCALL   `??zb_BindDevice::?relay`; Banked call to: zb_BindDevice
    426              }
    427              else{
    428              }
    429            }
    430          }
   \                     ??zb_ReceiveDataIndication_5:
   \   000064   D083         POP     DPH
   \   000066   D082         POP     DPL
   \   000068   02....       LJMP    ?BRET
   \   00006B                REQUIRE P0SEL
   \   00006B                REQUIRE _A_P0
   \   00006B                REQUIRE P0DIR
    431          
    432          /******************************************************************************
    433           * @fn          uartRxCB
    434           *
    435           * @brief       Callback function for UART
    436           *
    437           * @param       port - UART port
    438           *              event - UART event that caused callback
    439           *
    440           * @return      none
    441           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    442          void uartRxCB( uint8 port, uint8 event )
   \                     uartRxCB:
    443          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 135
   \   000005   7479         MOV     A,#0x79
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    444            (void)port;
    445          
    446            uint8 pBuf[RX_BUF_LEN];
    447            uint16 cmd;
    448            uint16 len;
    449          
    450            if ( event != HAL_UART_TX_EMPTY )
   \   00000C   7410         MOV     A,#0x10
   \   00000E   6E           XRL     A,R6
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??uartRxCB_0 & 0xFFFF
    451            {
    452              // Read from UART
    453              len = HalUARTRead( HAL_UART_PORT_0, pBuf, RX_BUF_LEN );
    454          
    455              if ( len > 0 )
   \   000014                ; Setup parameters for call to function HalUARTRead
   \   000014   7C80         MOV     R4,#-0x80
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7407         MOV     A,#0x7
   \   00001A   12....       LCALL   ?XSTACK_DISP101_8
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   12....       LCALL   `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000022   8B..         MOV     ?V1,R3
   \   000024   EA           MOV     A,R2
   \   000025   45..         ORL     A,?V1
   \   000027   6071         JZ      ??uartRxCB_0
    456              {
    457                cmd = BUILD_UINT16(pBuf[SYS_PING_CMD_OFFSET + 1], pBuf[SYS_PING_CMD_OFFSET]);
    458          
    459                if( (pBuf[FRAME_SOF_OFFSET] == CPT_SOP) && (cmd == SYS_PING_REQUEST) )
   \   000029   7407         MOV     A,#0x7
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   64FE         XRL     A,#0xfe
   \   000031   7067         JNZ     ??uartRxCB_0
   \   000033   7409         MOV     A,#0x9
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   7408         MOV     A,#0x8
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   EA           MOV     A,R2
   \   000042   F8           MOV     R0,A
   \   000043   7421         MOV     A,#0x21
   \   000045   68           XRL     A,R0
   \   000046   49           ORL     A,R1
   \   000047   7051         JNZ     ??uartRxCB_0
    460                {
    461                  sysPingReqRcvd();
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   74FE         MOV     A,#-0x2
   \   000051   F0           MOVX    @DPTR,A
   \   000052   7401         MOV     A,#0x1
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7402         MOV     A,#0x2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   7461         MOV     A,#0x61
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   7401         MOV     A,#0x1
   \   000067   F0           MOVX    @DPTR,A
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   7441         MOV     A,#0x41
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   7405         MOV     A,#0x5
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E4           CLR     A
   \   000076   F0           MOVX    @DPTR,A
   \   000077   04           INC     A
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   7800         MOV     R0,#0x0
   \   00007D   7905         MOV     R1,#0x5
   \                     ??uartRxCB_1:
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C8           XCH     A,R0
   \   000081   68           XRL     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   D9F9         DJNZ    R1,??uartRxCB_1
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E8           MOV     A,R0
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D                ; Setup parameters for call to function HalUARTWrite
   \   00008D   7C07         MOV     R4,#0x7
   \   00008F   7D00         MOV     R5,#0x0
   \   000091   AA..         MOV     R2,?XSP + 0
   \   000093   AB..         MOV     R3,?XSP + 1
   \   000095   7900         MOV     R1,#0x0
   \   000097   12....       LCALL   `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    462                }
    463              }
    464            }
    465          }
   \                     ??uartRxCB_0:
   \   00009A   7487         MOV     A,#-0x79
   \   00009C   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for myStartRetryDelay>`:
   \   000000   0A           DB 10

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for doorState>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleOsalEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleOsalEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_StartConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_StartConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_SendDataConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_SendDataConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_BindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_BindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_AllowBindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_AllowBindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_FindDeviceConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_FindDeviceConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_ReceiveDataIndication::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??uartRxCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uartRxCB
    466          
    467          /******************************************************************************
    468           * @fn          sysPingReqRcvd
    469           *
    470           * @brief       Ping request received
    471           *
    472           * @param       none
    473           *
    474           * @return      none
    475           */
    476          static void sysPingReqRcvd(void)
    477          {
    478             sysPingRsp();
    479          }
    480          
    481          /******************************************************************************
    482           * @fn          sysPingRsp
    483           *
    484           * @brief       Build and send Ping response
    485           *
    486           * @param       none
    487           *
    488           * @return      none
    489           */
    490          static void sysPingRsp(void)
    491          {
    492            uint8 pBuf[SYS_PING_RSP_LENGTH];
    493          
    494            // Start of Frame Delimiter
    495            pBuf[FRAME_SOF_OFFSET] = CPT_SOP;
    496          
    497            // Length
    498            pBuf[FRAME_LENGTH_OFFSET] = 2;
    499          
    500            // Command type
    501            pBuf[FRAME_CMD0_OFFSET] = LO_UINT16(SYS_PING_RESPONSE);
    502            pBuf[FRAME_CMD1_OFFSET] = HI_UINT16(SYS_PING_RESPONSE);
    503          
    504            // Stack profile
    505            pBuf[FRAME_DATA_OFFSET] = LO_UINT16(STACK_PROFILE);
    506            pBuf[FRAME_DATA_OFFSET + 1] = HI_UINT16(STACK_PROFILE);
    507          
    508            // Frame Check Sequence
    509            pBuf[SYS_PING_RSP_LENGTH - 1] = calcFCS(&pBuf[FRAME_LENGTH_OFFSET], (SYS_PING_RSP_LENGTH - 2));
    510          
    511            // Write frame to UART
    512            HalUARTWrite(HAL_UART_PORT_0,pBuf, SYS_PING_RSP_LENGTH);
    513          }
    514          
    515          /******************************************************************************
    516           * @fn          sendGtwReport
    517           *
    518           * @brief       Build and send gateway report
    519           *
    520           * @param       none
    521           *
    522           * @return      none
    523           */
    524          static void sendGtwReport(gtwData_t *gtwData)
                             ^
Warning[Pe177]: function "sendGtwReport" was declared but never referenced
    525          {
    526            uint8 pFrame[ZB_RECV_LENGTH];
    527          
    528            // Start of Frame Delimiter
    529            pFrame[FRAME_SOF_OFFSET] = CPT_SOP; // Start of Frame Delimiter
    530          
    531            // Length
    532            pFrame[FRAME_LENGTH_OFFSET] = 10;
    533          
    534            // Command type
    535            pFrame[FRAME_CMD0_OFFSET] = LO_UINT16(ZB_RECEIVE_DATA_INDICATION);
    536            pFrame[FRAME_CMD1_OFFSET] = HI_UINT16(ZB_RECEIVE_DATA_INDICATION);
    537          
    538            // Source address
    539            pFrame[FRAME_DATA_OFFSET + ZB_RECV_SRC_OFFSET] = LO_UINT16(gtwData->source);
    540            pFrame[FRAME_DATA_OFFSET + ZB_RECV_SRC_OFFSET+ 1] = HI_UINT16(gtwData->source);
    541          
    542            // Command ID
    543           // pFrame[FRAME_DATA_OFFSET + ZB_RECV_CMD_OFFSET] = LO_UINT16(SENSOR_REPORT_CMD_ID);
    544           // pFrame[FRAME_DATA_OFFSET + ZB_RECV_CMD_OFFSET+ 1] = HI_UINT16(SENSOR_REPORT_CMD_ID);
    545          
    546            // Length
    547            pFrame[FRAME_DATA_OFFSET + ZB_RECV_LEN_OFFSET] = LO_UINT16(4);
    548            pFrame[FRAME_DATA_OFFSET + ZB_RECV_LEN_OFFSET+ 1] = HI_UINT16(4);
    549          
    550            // Data
    551            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET] = gtwData->temp;
    552            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET+ 1] = gtwData->voltage;
    553            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET+ 2] = LO_UINT16(gtwData->parent);
    554            pFrame[FRAME_DATA_OFFSET + ZB_RECV_DATA_OFFSET+ 3] = HI_UINT16(gtwData->parent);
    555          
    556            // Frame Check Sequence
    557            pFrame[ZB_RECV_LENGTH - 1] = calcFCS(&pFrame[FRAME_LENGTH_OFFSET], (ZB_RECV_LENGTH - 2) );
    558          
    559            // Write report to UART
    560            HalUARTWrite(HAL_UART_PORT_0,pFrame, ZB_RECV_LENGTH);
    561          }
    562          
    563          /******************************************************************************
    564           * @fn          calcFCS
    565           *
    566           * @brief       This function calculates the FCS checksum for the serial message
    567           *
    568           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
    569           *              len - Length of the pBuf.
    570           *
    571           * @return      The calculated FCS.
    572           ******************************************************************************
    573           */
    574          static uint8 calcFCS(uint8 *pBuf, uint8 len)
    575          {
    576            uint8 rtrn = 0;
    577          
    578            while ( len-- )
    579            {
    580              rtrn ^= *pBuf++;
    581            }
    582          
    583            return rtrn;
    584          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    145   uartRxCB
        0    145   -> HalUARTRead
        0    145   -> HalUARTWrite
      0      0   zb_AllowBindConfirm
      0      9   zb_BindConfirm
        0      9   -> HalLedSet
        0      9   -> zb_AllowBind
      0      0   zb_FindDeviceConfirm
      0      0   zb_HandleKeys
      1     16   zb_HandleOsalEvent
        0     11   -> initUart
        0     15   -> osal_start_timerEx
        0     16   -> zb_SendDataRequest
        0     11   -> zb_StartRequest
      2      4   zb_ReceiveDataIndication
        2      0   -> zb_AllowBind
        2      0   -> zb_BindDevice
      0      0   zb_SendDataConfirm
      0     16   zb_StartConfirm
        0     12   -> HalLedSet
        0     16   -> osal_start_timerEx
        0     12   -> zb_AllowBind


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for doorState>
       1  ?<Initializer for myStartRetryDelay>
       8  ?Subroutine0
       1  P0DIR
       1  P0INP
       1  P0SEL
       1  P2INP
       1  _A_P0
       4  __Constant_64
       1  appState
       1  buttonState
       1  doorState
       1  myStartRetryDelay
     159  uartRxCB
       6  uartRxCB::?relay
       3  zb_AllowBindConfirm
       6  zb_AllowBindConfirm::?relay
      58  zb_BindConfirm
       6  zb_BindConfirm::?relay
       3  zb_FindDeviceConfirm
       6  zb_FindDeviceConfirm::?relay
       3  zb_HandleKeys
       6  zb_HandleKeys::?relay
     179  zb_HandleOsalEvent
       6  zb_HandleOsalEvent::?relay
       4  zb_InCmdList
       4  zb_OutCmdList
     107  zb_ReceiveDataIndication
       6  zb_ReceiveDataIndication::?relay
       3  zb_SendDataConfirm
       6  zb_SendDataConfirm::?relay
      12  zb_SimpleDesc
     119  zb_StartConfirm
       6  zb_StartConfirm::?relay

 
 642 bytes in segment BANKED_CODE
  54 bytes in segment BANK_RELAYS
   5 bytes in segment SFR_AN
   2 bytes in segment XDATA_I
   2 bytes in segment XDATA_ID
  24 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 698 bytes of CODE  memory
  20 bytes of CONST memory (+ 4 bytes shared)
   0 bytes of DATA  memory (+ 5 bytes shared)
   4 bytes of XDATA memory

Errors: none
Warnings: 4
