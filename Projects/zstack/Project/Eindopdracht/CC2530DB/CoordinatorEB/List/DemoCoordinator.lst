###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                16/Mar/2016  14:25:31
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
#    Command line       =  
#        -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0EEE
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        xNV_RESTORE -D ZTOOL_P1 -lC
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\
#        -lA
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\Source\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Oh --require_prototypes
#    List file          =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\DemoCoordinator.lst
#    Object file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\Obj\DemoCoordinator.r51
#
###############################################################################

C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
      1          /**************************************************************************************************
      2            Filename:       DemoCoordinator.c
      3          
      4            Description:    Coordinator application for the sensor demo utilizing Simple API.
      5          
      6                            The collector node can be set in a state where it accepts
      7                            incoming reports from the sensor nodes, and can send the reports
      8                            via the UART to a PC tool. The collector node in this state
      9                            functions as a gateway. The collector nodes that are not in the
     10                            gateway node function as routers in the network.
     11          
     12          
     13            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15            IMPORTANT: Your use of this Software is limited to those specific rights
     16            granted under the terms of a software license agreement between the user
     17            who downloaded the software, his/her employer (which must be your employer)
     18            and Texas Instruments Incorporated (the "License").  You may not use this
     19            Software unless you agree to abide by the terms of the License. The License
     20            limits your use, and you acknowledge, that the Software may not be modified,
     21            copied or distributed unless embedded on a Texas Instruments microcontroller
     22            or used solely and exclusively in conjunction with a Texas Instruments radio
     23            frequency transceiver, which is integrated into your product.  Other than for
     24            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25            works of, modify, distribute, perform, display or sell this Software and/or
     26            its documentation for any purpose.
     27          
     28            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40            Should you have any questions regarding your right to use this Software,
     41            contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /******************************************************************************
     45           * INCLUDES
     46           */
     47          
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "sapi.h"
     52          #include "hal_key.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     53          #include "hal_led.h"
     54          #include "hal_lcd.h"
     55          #include "hal_uart.h"
     56          #include "DemoApp.h"
     57          #include "hal_adc.h"
     58          
     59          /******************************************************************************
     60           * CONSTANTS
     61           */
     62          
     63          // General UART frame offsets
     64          #define FRAME_SOF_OFFSET                    0
     65          #define FRAME_LENGTH_OFFSET                 1
     66          #define FRAME_CMD0_OFFSET                   2
     67          #define FRAME_CMD1_OFFSET                   3
     68          #define FRAME_DATA_OFFSET                   4
     69          
     70          // ZB_RECEIVE_DATA_INDICATION offsets
     71          #define ZB_RECV_SRC_OFFSET                  0
     72          #define ZB_RECV_CMD_OFFSET                  2
     73          #define ZB_RECV_LEN_OFFSET                  4
     74          #define ZB_RECV_DATA_OFFSET                 6
     75          #define ZB_RECV_FCS_OFFSET                  8
     76          
     77          // ZB_RECEIVE_DATA_INDICATION frame length
     78          #define ZB_RECV_LENGTH                      15
     79          
     80          // PING response frame length and offset
     81          #define SYS_PING_RSP_LENGTH                 7
     82          #define SYS_PING_CMD_OFFSET                 1
     83          
     84          // Stack Profile
     85          #define ZIGBEE_2007                         0x0040
     86          #define ZIGBEE_PRO_2007                     0x0041
     87          
     88          #ifdef ZIGBEEPRO
     89          #define STACK_PROFILE                       ZIGBEE_PRO_2007
     90          #else
     91          #define STACK_PROFILE                       ZIGBEE_2007
     92          #endif
     93          
     94          #define CPT_SOP                             0xFE
     95          #define SYS_PING_REQUEST                    0x0021
     96          #define SYS_PING_RESPONSE                   0x0161
     97          #define ZB_RECEIVE_DATA_INDICATION          0x8746
     98          
     99          // Application States
    100          #define APPSTATE_INIT                       0
    101          #define APPSTATE_STARTED                    1
    102          
    103          // Application osal event identifiers
    104          #define RETRY_START_EVT                        0x0001
    105          #define CHECK_LOCK_STATUS_EVT                  0x0002
    106          #define CHECK_LDR_STATUS_EVT                  0x0002
    107          
    108          /******************************************************************************
    109           * TYPEDEFS
    110           */
    111          typedef struct
    112          {
    113            uint16              source;
    114            uint16              parent;
    115            uint8               temp;
    116            uint8               voltage;
    117          } gtwData_t;
    118          
    119          /******************************************************************************
    120           * LOCAL VARIABLES
    121           */
    122          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    123          static uint8 appState = APPSTATE_INIT;
   \                     appState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    124          static uint8 retryStartDelay =    10;
   \                     retryStartDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for retryStartDelay>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    125          static uint8 checkLockStateDelay = 255;
   \                     checkLockStateDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for checkLockStateDelay>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    126          static uint8 checkLdrStateDelay = 255;
   \                     checkLdrStateDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for checkLdrStateDelay>`
   \   000001                REQUIRE __INIT_XDATA_I
    127          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    128          static uint8 lastKnownLockState = 0xFF; //init waarde
   \                     lastKnownLockState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for lastKnownLockState>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    129          static uint8 lastKnownLightState = 0xFF;
   \                     lastKnownLightState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for lastKnownLightState>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    130          static uint8 lightState = 0;
   \                     lightState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    131          
    132          /******************************************************************************
    133           * LOCAL FUNCTIONS
    134           */
    135          
    136          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    137          static void sysPingReqRcvd(void);
    138          static void sysPingRsp(void);
    139          
    140          /******************************************************************************
    141           * GLOBAL VARIABLES
    142           */
    143          
    144          // Inputs and Outputs for Collector device
    145          #define NUM_OUT_CMD_COLLECTOR           2
    146          #define NUM_IN_CMD_COLLECTOR            2
    147          
    148          // List of output and input commands for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    149          const cId_t zb_InCmdList[NUM_IN_CMD_COLLECTOR] =
   \                     zb_InCmdList:
   \   000000   0100         DW 1
   \   000002   0200         DW 2
    150          {
    151            LOCK_CONTROL_CMD_ID,
    152            LIGHT_CONTROL_CMD_ID
    153          };

   \                                 In  segment XDATA_ROM_C, align 1
    154          const cId_t zb_OutCmdList[NUM_OUT_CMD_COLLECTOR] =
   \                     zb_OutCmdList:
   \   000000   0300         DW 3
   \   000002   0400         DW 4
    155          {
    156            LOCK_STATUS_CMD_ID,
    157            LIGHT_STATUS_CMD_ID
    158          };
    159          
    160          
    161          // Define SimpleDescriptor for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    162          const SimpleDescriptionFormat_t zb_SimpleDesc =
   \                     zb_SimpleDesc:
   \   000000   02           DB 2
   \   000001   200F         DW 3872
   \   000003   0200         DW 2
   \   000005   01           DB 1
   \   000006   02           DB 2
   \   000007   ....         DW zb_InCmdList
   \   000009   02           DB 2
   \   00000A   ....         DW zb_OutCmdList
    163          {
    164            MY_ENDPOINT_ID,             //  Endpoint
    165            MY_PROFILE_ID,              //  Profile ID
    166            DEV_ID_COLLECTOR,           //  Device ID
    167            DEVICE_VERSION_COLLECTOR,   //  Device Version
    168            0,                          //  Reserved
    169            NUM_IN_CMD_COLLECTOR,       //  Number of Input Commands
    170            (cId_t *) zb_InCmdList,     //  Input Command List
    171            NUM_OUT_CMD_COLLECTOR,      //  Number of Output Commands
    172            (cId_t *) zb_OutCmdList     //  Output Command List
    173          };
    174          
    175          /******************************************************************************
    176           * FUNCTIONS
    177           */
    178          
    179          /******************************************************************************
    180           * @fn          zb_HandleOsalEvent
    181           *
    182           * @brief       The zb_HandleOsalEvent function is called by the operating
    183           *              system when a task event is set
    184           *
    185           * @param       event - Bitmask containing the events that have been set
    186           *
    187           * @return      none
    188           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    189          void zb_HandleOsalEvent( uint16 event )
   \                     zb_HandleOsalEvent:
    190          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    191            if( event & SYS_EVENT_MSG )
    192            {
    193            }
    194          
    195            if( event & ZB_ENTRY_EVENT || event & RETRY_START_EVT  )
   \   00000E   EE           MOV     A,R6
   \   00000F   5401         ANL     A,#0x1
   \   000011   F8           MOV     R0,A
   \   000012   EF           MOV     A,R7
   \   000013   5410         ANL     A,#0x10
   \   000015   F9           MOV     R1,A
   \   000016   E8           MOV     A,R0
   \   000017   49           ORL     A,R1
   \   000018   6003         JZ      ??zb_HandleOsalEvent_0
    196            {
    197              zb_StartRequest();
   \   00001A                ; Setup parameters for call to function zb_StartRequest
   \   00001A   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    198            }
    199          
    200            
    201            if (event & CHECK_LOCK_STATUS_EVT ){
   \                     ??zb_HandleOsalEvent_0:
   \   00001D   EE           MOV     A,R6
   \   00001E   5402         ANL     A,#0x2
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??zb_HandleOsalEvent_1 & 0xFFFF
    202              
    203              uint8 lockState = (MCU_IO_GET(0,2) == 0);
   \   000025   A282         MOV     C,0x80.2
   \   000027   4004         JC      ??zb_HandleOsalEvent_2
   \   000029   D2F0         SETB    B.0
   \   00002B   8002         SJMP    ??zb_HandleOsalEvent_3
   \                     ??zb_HandleOsalEvent_2:
   \   00002D   C2F0         CLR     B.0
   \                     ??zb_HandleOsalEvent_3:
   \   00002F   A2F0         MOV     C,B.0
   \   000031   E4           CLR     A
   \   000032   33           RLC     A
   \   000033   FE           MOV     R6,A
    204              
    205              if (lockState != lastKnownLockState){
   \   000034   90....       MOV     DPTR,#lastKnownLockState
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6E           XRL     A,R6
   \   000039   603F         JZ      ??zb_HandleOsalEvent_4
    206                uint8 pData[LOCK_CMD_LENGTH];
    207                pData[LOCK_CMD_OFFSET] = lockState;
   \   00003B   EE           MOV     A,R6
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   F0           MOVX    @DPTR,A
    208                uint8 txOptions;
    209                zb_SendDataRequest( 0xFFFE, LOCK_STATUS_CMD_ID, LOCK_CMD_LENGTH , pData, 0, txOptions, 0 );
                                                                                                   ^
Warning[Pe549]: variable "txOptions" is used before its value is set
   \   000043                ; Setup parameters for call to function zb_SendDataRequest
   \   000043   75..00       MOV     ?V0,#0x0
   \   000046   78..         MOV     R0,#?V0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004B   78..         MOV     R0,#?V0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000050   78..         MOV     R0,#?V0
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?XSTACK_DISP100_8
   \   00005A   88..         MOV     ?V0,R0
   \   00005C   89..         MOV     ?V1,R1
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   7901         MOV     R1,#0x1
   \   000065   7C03         MOV     R4,#0x3
   \   000067   7D00         MOV     R5,#0x0
   \   000069   7AFE         MOV     R2,#-0x2
   \   00006B   7BFF         MOV     R3,#-0x1
   \   00006D   12....       LCALL   `??zb_SendDataRequest::?relay`; Banked call to: zb_SendDataRequest
   \   000070   7405         MOV     A,#0x5
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
    210                lastKnownLockState = lockState;
   \   000075   EE           MOV     A,R6
   \   000076   90....       MOV     DPTR,#lastKnownLockState
   \   000079   F0           MOVX    @DPTR,A
    211              }
    212              
    213              osal_start_timerEx( sapi_TaskID, CHECK_LOCK_STATUS_EVT , checkLockStateDelay );
   \                     ??zb_HandleOsalEvent_4:
   \   00007A                ; Setup parameters for call to function osal_start_timerEx
   \   00007A   90....       MOV     DPTR,#checkLockStateDelay
   \   00007D   12....       LCALL   ?Subroutine1 & 0xFFFF
    214            }
   \                     ??CrossCallReturnLabel_0:
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000083   7A02         MOV     R2,#0x2
   \   000085   7B00         MOV     R3,#0x0
   \   000087   90....       MOV     DPTR,#sapi_TaskID
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   F9           MOV     R1,A
   \   00008C   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00008F   7404         MOV     A,#0x4
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
    215          
    216          
    217            if (event & CHECK_LDR_STATUS_EVT ){
    218              uint8 newLightState = 0;
   \   000094   7E00         MOV     R6,#0x0
    219              
    220              if(lightState){
   \   000096   90....       MOV     DPTR,#lightState
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   6012         JZ      ??zb_HandleOsalEvent_5
    221                 uint16 LDRValue = HalAdcRead(HAL_ADC_CHANNEL_0, HAL_ADC_RESOLUTION_8);
    222                 if(LDRValue > 100){
   \   00009C                ; Setup parameters for call to function HalAdcRead
   \   00009C   7A01         MOV     R2,#0x1
   \   00009E   7900         MOV     R1,#0x0
   \   0000A0   12....       LCALL   `??HalAdcRead::?relay`; Banked call to: HalAdcRead
   \   0000A3   C3           CLR     C
   \   0000A4   EA           MOV     A,R2
   \   0000A5   9465         SUBB    A,#0x65
   \   0000A7   EB           MOV     A,R3
   \   0000A8   9400         SUBB    A,#0x0
   \   0000AA   4002         JC      ??zb_HandleOsalEvent_5
    223                   newLightState = 1;
   \   0000AC   7E01         MOV     R6,#0x1
    224                 }
    225              }
    226              
    227              if(newLightState != lastKnownLightState){
   \                     ??zb_HandleOsalEvent_5:
   \   0000AE   90....       MOV     DPTR,#lastKnownLightState
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   6E           XRL     A,R6
   \   0000B3   6051         JZ      ??zb_HandleOsalEvent_6
    228                MCU_IO_OUTPUT(0, 4, newLightState);
   \   0000B5   53F3EF       ANL     0xf3,#0xef
   \   0000B8   EE           MOV     A,R6
   \   0000B9   C4           SWAP    A
   \   0000BA   54F0         ANL     A,#0xf0
   \   0000BC   F8           MOV     R0,A
   \   0000BD   E580         MOV     A,0x80
   \   0000BF   54EF         ANL     A,#0xef
   \   0000C1   48           ORL     A,R0
   \   0000C2   F580         MOV     0x80,A
   \   0000C4   43FD10       ORL     0xfd,#0x10
    229                
    230                uint8 pData[LIGHT_CMD_LENGTH];
    231                pData[LIGHT_CMD_OFFSET] = newLightState;
   \   0000C7   EE           MOV     A,R6
   \   0000C8   85..82       MOV     DPL,?XSP + 0
   \   0000CB   85..83       MOV     DPH,?XSP + 1
   \   0000CE   F0           MOVX    @DPTR,A
    232                uint8 txOptions;
    233                zb_SendDataRequest( 0xFFFE, LIGHT_STATUS_CMD_ID, LIGHT_CMD_LENGTH , pData, 0, txOptions, 0 );
                                                                                                     ^
Warning[Pe549]: variable "txOptions" is used before its value is set

  static uint8 appState = APPSTATE_INIT;
               ^
"C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c",123  Warning[Pe550]: 
          variable "appState" was set but never used
   \   0000CF                ; Setup parameters for call to function zb_SendDataRequest
   \   0000CF   75..00       MOV     ?V0,#0x0
   \   0000D2   78..         MOV     R0,#?V0
   \   0000D4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D7   78..         MOV     R0,#?V0
   \   0000D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DC   78..         MOV     R0,#?V0
   \   0000DE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E1   7403         MOV     A,#0x3
   \   0000E3   12....       LCALL   ?XSTACK_DISP100_8
   \   0000E6   88..         MOV     ?V0,R0
   \   0000E8   89..         MOV     ?V1,R1
   \   0000EA   78..         MOV     R0,#?V0
   \   0000EC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EF   7901         MOV     R1,#0x1
   \   0000F1   7C04         MOV     R4,#0x4
   \   0000F3   7D00         MOV     R5,#0x0
   \   0000F5   7AFE         MOV     R2,#-0x2
   \   0000F7   7BFF         MOV     R3,#-0x1
   \   0000F9   12....       LCALL   `??zb_SendDataRequest::?relay`; Banked call to: zb_SendDataRequest
   \   0000FC   7405         MOV     A,#0x5
   \   0000FE   12....       LCALL   ?DEALLOC_XSTACK8
    234                lastKnownLightState = newLightState;
   \   000101   EE           MOV     A,R6
   \   000102   90....       MOV     DPTR,#lastKnownLightState
   \   000105   F0           MOVX    @DPTR,A
    235              }
    236              
    237              osal_start_timerEx( sapi_TaskID, CHECK_LDR_STATUS_EVT , checkLdrStateDelay );
   \                     ??zb_HandleOsalEvent_6:
   \   000106                ; Setup parameters for call to function osal_start_timerEx
   \   000106   90....       MOV     DPTR,#checkLdrStateDelay
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   F5..         MOV     ?V0,A
   \   00010C   E4           CLR     A
   \   00010D   F5..         MOV     ?V1,A
   \   00010F   78..         MOV     R0,#?V0
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000114   7A02         MOV     R2,#0x2
   \   000116   7B00         MOV     R3,#0x0
   \   000118   90....       MOV     DPTR,#sapi_TaskID
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   F9           MOV     R1,A
   \   00011D   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000120   7404         MOV     A,#0x4
   \   000122   12....       LCALL   ?DEALLOC_XSTACK8
    238                
    239                 /*uint8 pData[LOCK_CMD_LENGTH];
    240                 pData[LOCK_CMD_OFFSET] = lockState;
    241                 uint8 txOptions;
    242                 zb_SendDataRequest( 0xFFFE, LOCK_STATUS_CMD_ID, LOCK_CMD_LENGTH , pData, 0, txOptions, 0 );
    243                if (LDRState > 0){
    244                   //uint8 pData[LOCK_CMD_LENGTH];
    245                  //uint8 pData[LOCK_CMD_LENGTH];
    246                 // pData[LOCK_CMD_OFFSET] = lockState;
    247                  //uint8 txOptions;
    248                  
    249                  //lastKnownLockState = lockState;
    250                  LDRState = 10;
    251                }
    252                 //uint8 pData[LOCK_CMD_LENGTH];*/
    253            }
    254          }
   \                     ??zb_HandleOsalEvent_1:
   \   000125   7401         MOV     A,#0x1
   \   000127   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012A                REQUIRE ?Subroutine0
   \   00012A                REQUIRE _A_P0
   \   00012A                REQUIRE P0SEL
   \   00012A                REQUIRE P0DIR
   \   00012A                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   E4           CLR     A
   \   000004   F5..         MOV     ?V1,A
   \   000006   F5..         MOV     ?V2,A
   \   000008   F5..         MOV     ?V3,A
   \   00000A   78..         MOV     R0,#?V0
   \   00000C   22           RET
    255          
    256          /******************************************************************************
    257           * @fn      zb_HandleKeys
    258           *
    259           * @brief   Handles all key events for this device.
    260           *
    261           * @param   shift - true if in shift/alt.
    262           * @param   keys - bit field for key events. Valid entries:
    263           *                 EVAL_SW4
    264           *                 EVAL_SW3
    265           *                 EVAL_SW2
    266           *                 EVAL_SW1
    267           *
    268           * @return  none
    269           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    270          void zb_HandleKeys( uint8 shift, uint8 keys )
   \                     zb_HandleKeys:
    271          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    272            // Shift is used to make each button/switch dual purpose.
    273            if ( shift )
    274            {
    275              if ( keys & HAL_KEY_SW_1 )
    276              {
    277              }
    278              if ( keys & HAL_KEY_SW_2 )
    279              {
    280              }
    281              if ( keys & HAL_KEY_SW_3 )
    282              {
    283              }
    284              if ( keys & HAL_KEY_SW_4 )
    285              {
    286              }
    287            }
    288            else
    289            {
    290              if ( keys & HAL_KEY_SW_1 )
    291              {
    292              }
    293              if ( keys & HAL_KEY_SW_2 )
    294              {
    295              }
    296              if ( keys & HAL_KEY_SW_3 )
    297              {
    298              }
    299              if ( keys & HAL_KEY_SW_4 )
    300              {
    301              }
    302            }
    303          }
   \   000000   02....       LJMP    ?BRET
    304          
    305          /******************************************************************************
    306           * @fn          zb_StartConfirm
    307           *
    308           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    309           *              after a start request operation completes
    310           *
    311           * @param       status - The status of the start operation.  Status of
    312           *                       ZB_SUCCESS indicates the start operation completed
    313           *                       successfully.  Else the status is an error code.
    314           *
    315           * @return      none
    316           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    317          void zb_StartConfirm( uint8 status )
   \                     zb_StartConfirm:
    318          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    319            // If the device sucessfully started, change state to running
    320            if ( status == ZB_SUCCESS )
   \   000006   704D         JNZ     ??zb_StartConfirm_0
    321            {
    322              HalAdcInit();
   \   000008                ; Setup parameters for call to function HalAdcInit
   \   000008   12....       LCALL   `??HalAdcInit::?relay`; Banked call to: HalAdcInit
    323              //init lock sensor
    324              MCU_IO_DIR_INPUT(0, 2);
   \   00000B   53FDFB       ANL     0xfd,#0xfb
    325              MCU_IO_INPUT(0,2,MCU_IO_PULLDOWN);
   \   00000E   53F3FB       ANL     0xf3,#0xfb
   \   000011   53FDFB       ANL     0xfd,#0xfb
   \   000014   538FFB       ANL     0x8f,#0xfb
   \   000017   43F720       ORL     0xf7,#0x20
    326              
    327              //init lamp
    328              MCU_IO_DIR_OUTPUT(0, 4);
   \   00001A   43FD10       ORL     0xfd,#0x10
    329              MCU_IO_OUTPUT(0, 4, 0);
   \   00001D   53F3EF       ANL     0xf3,#0xef
   \   000020   C284         CLR     0x80.4
   \   000022   43FD10       ORL     0xfd,#0x10
    330              
    331              //init lock
    332              MCU_IO_DIR_OUTPUT(0, 7);
   \   000025   43FD80       ORL     0xfd,#0x80
    333              MCU_IO_OUTPUT(0, 7, DOOR_OPEN);
   \   000028   53F37F       ANL     0xf3,#0x7f
   \   00002B   D287         SETB    0x80.7
   \   00002D   43FD80       ORL     0xfd,#0x80
    334              
    335              MCU_IO_DIR_INPUT(0, 0);
   \   000030   53FDFE       ANL     0xfd,#0xfe
    336              
    337              
    338              zb_AllowBind( 0xFF );
   \   000033                ; Setup parameters for call to function zb_AllowBind
   \   000033   79FF         MOV     R1,#-0x1
   \   000035   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    339              
    340              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
   \   000038                ; Setup parameters for call to function HalLedSet
   \   000038   7A01         MOV     R2,#0x1
   \   00003A   7901         MOV     R1,#0x1
   \   00003C   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    341              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   00003F                ; Setup parameters for call to function HalLedSet
   \   00003F   7A00         MOV     R2,#0x0
   \   000041   7902         MOV     R1,#0x2
   \   000043   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    342              HalLedSet( HAL_LED_3, HAL_LED_MODE_OFF );
   \   000046                ; Setup parameters for call to function HalLedSet
   \   000046   7A00         MOV     R2,#0x0
   \   000048   7904         MOV     R1,#0x4
   \   00004A   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    343              
    344              // Change application state
    345              appState = APPSTATE_STARTED;
   \   00004D   90....       MOV     DPTR,#appState
   \   000050   7401         MOV     A,#0x1
   \   000052   F0           MOVX    @DPTR,A
   \   000053   801A         SJMP    ??zb_StartConfirm_1
    346            }
    347            else
    348            {
    349              // Try again later with a delay
    350              osal_start_timerEx( sapi_TaskID, RETRY_START_EVT, retryStartDelay );
   \                     ??zb_StartConfirm_0:
   \   000055                ; Setup parameters for call to function osal_start_timerEx
   \   000055   90....       MOV     DPTR,#retryStartDelay
   \   000058   12....       LCALL   ?Subroutine1 & 0xFFFF
    351            }
   \                     ??CrossCallReturnLabel_1:
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00005E   7A01         MOV     R2,#0x1
   \   000060   7B00         MOV     R3,#0x0
   \   000062   90....       MOV     DPTR,#sapi_TaskID
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F9           MOV     R1,A
   \   000067   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00006A   7404         MOV     A,#0x4
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
    352          }
   \                     ??zb_StartConfirm_1:
   \   00006F   80..         SJMP    ?Subroutine0
   \   000071                REQUIRE P0DIR
   \   000071                REQUIRE P0SEL
   \   000071                REQUIRE P0INP
   \   000071                REQUIRE P2INP
   \   000071                REQUIRE _A_P0
    353          
    354          /******************************************************************************
    355           * @fn          zb_SendDataConfirm
    356           *
    357           * @brief       The zb_SendDataConfirm callback function is called by the
    358           *              ZigBee stack after a send data operation completes
    359           *
    360           * @param       handle - The handle identifying the data transmission.
    361           *              status - The status of the operation.
    362           *
    363           * @return      none
    364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    365          void zb_SendDataConfirm( uint8 handle, uint8 status )
   \                     zb_SendDataConfirm:
    366          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    367            if (status == ZB_SUCCESS){
    368            }
    369          }
   \   000000   02....       LJMP    ?BRET
    370          
    371          /******************************************************************************
    372           * @fn          zb_BindConfirm
    373           *
    374           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    375           *              after a bind operation completes.
    376           *
    377           * @param       commandId - The command ID of the binding being confirmed.
    378           *              status - The status of the bind operation.
    379           *
    380           * @return      none
    381           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    382          void zb_BindConfirm( uint16 commandId, uint8 status )
   \                     zb_BindConfirm:
    383          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V4,R1
    384            zb_AllowBind( 0xFF );
   \   00000B                ; Setup parameters for call to function zb_AllowBind
   \   00000B   79FF         MOV     R1,#-0x1
   \   00000D   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    385            
    386            if (status == ZB_SUCCESS){
   \   000010   E5..         MOV     A,?V4
   \   000012   7039         JNZ     ??zb_BindConfirm_0
    387              if(commandId == LOCK_STATUS_CMD_ID){
   \   000014   7403         MOV     A,#0x3
   \   000016   6E           XRL     A,R6
   \   000017   4F           ORL     A,R7
   \   000018   700C         JNZ     ??zb_BindConfirm_1
    388                HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON);
   \   00001A                ; Setup parameters for call to function HalLedSet
   \   00001A   7A01         MOV     R2,#0x1
   \   00001C   7902         MOV     R1,#0x2
   \   00001E   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    389                osal_start_timerEx( sapi_TaskID, CHECK_LOCK_STATUS_EVT , checkLdrStateDelay );
   \   000021                ; Setup parameters for call to function osal_start_timerEx
   \   000021   90....       MOV     DPTR,#checkLdrStateDelay
   \   000024   8010         SJMP    ??zb_BindConfirm_2
    390              }
    391              else if(commandId == LIGHT_STATUS_CMD_ID){
   \                     ??zb_BindConfirm_1:
   \   000026   7404         MOV     A,#0x4
   \   000028   6E           XRL     A,R6
   \   000029   4F           ORL     A,R7
   \   00002A   7021         JNZ     ??zb_BindConfirm_0
    392                HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON);
   \   00002C                ; Setup parameters for call to function HalLedSet
   \   00002C   7A01         MOV     R2,#0x1
   \   00002E   7904         MOV     R1,#0x4
   \   000030   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    393                osal_start_timerEx( sapi_TaskID, CHECK_LDR_STATUS_EVT , checkLockStateDelay );
   \   000033                ; Setup parameters for call to function osal_start_timerEx
   \   000033   90....       MOV     DPTR,#checkLockStateDelay
    394              }
    395            }
   \                     ??zb_BindConfirm_2:
   \   000036   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000039   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00003C   7A02         MOV     R2,#0x2
   \   00003E   7B00         MOV     R3,#0x0
   \   000040   90....       MOV     DPTR,#sapi_TaskID
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000048   7404         MOV     A,#0x4
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
    396            
    397          }
   \                     ??zb_BindConfirm_0:
   \   00004D   7F05         MOV     R7,#0x5
   \   00004F   02....       LJMP    ?BANKED_LEAVE_XDATA
    398          
    399          /******************************************************************************
    400           * @fn          zb_AllowBindConfirm
    401           *
    402           * @brief       Indicates when another device attempted to bind to this device
    403           *
    404           * @param
    405           *
    406           * @return      none
    407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void zb_AllowBindConfirm( uint16 source )
   \                     zb_AllowBindConfirm:
    409          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    410            
    411          }
   \   000000   02....       LJMP    ?BRET
    412          
    413          /******************************************************************************
    414           * @fn          zb_FindDeviceConfirm
    415           *
    416           * @brief       The zb_FindDeviceConfirm callback function is called by the
    417           *              ZigBee stack when a find device operation completes.
    418           *
    419           * @param       searchType - The type of search that was performed.
    420           *              searchKey - Value that the search was executed on.
    421           *              result - The result of the search.
    422           *
    423           * @return      none
    424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    425          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
   \                     zb_FindDeviceConfirm:
    426          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    427            (void)searchType;
    428            (void)searchKey;
    429            (void)result;
    430          }
   \   000000   02....       LJMP    ?BRET
    431          
    432          /******************************************************************************
    433           * @fn          zb_ReceiveDataIndication
    434           *
    435           * @brief       The zb_ReceiveDataIndication callback function is called
    436           *              asynchronously by the ZigBee stack to notify the application
    437           *              when data is received from a peer device.
    438           *
    439           * @param       source - The short address of the peer device that sent the data
    440           *              command - The commandId associated with the data
    441           *              len - The number of bytes in the pData parameter
    442           *              pData - The data sent by the peer device
    443           *
    444           * @return      none
    445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    446          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
    447          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740E         MOV     A,#0xe
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
    448            if(*pData == IDENTIFIER_COMMAND ){
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   74F0         MOV     A,#-0x10
   \   00001B   68           XRL     A,R0
   \   00001C   702F         JNZ     ??zb_ReceiveDataIndication_0
    449                zb_AllowBind( 0x00 );
   \   00001E                ; Setup parameters for call to function zb_AllowBind
   \   00001E   7900         MOV     R1,#0x0
   \   000020   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    450                if(command == LOCK_CONTROL_CMD_ID){
   \   000023   7401         MOV     A,#0x1
   \   000025   6E           XRL     A,R6
   \   000026   4F           ORL     A,R7
   \   000027   7008         JNZ     ??zb_ReceiveDataIndication_1
    451                  zb_BindDevice( TRUE, LOCK_STATUS_CMD_ID, (uint8 *)NULL) ;
   \   000029                ; Setup parameters for call to function zb_BindDevice
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A03         MOV     R2,#0x3
   \   00002F   800C         SJMP    ??zb_ReceiveDataIndication_2
    452                }
    453                else if(command == LIGHT_CONTROL_CMD_ID){
   \                     ??zb_ReceiveDataIndication_1:
   \   000031   7402         MOV     A,#0x2
   \   000033   6E           XRL     A,R6
   \   000034   4F           ORL     A,R7
   \   000035   700F         JNZ     ??zb_ReceiveDataIndication_3
    454                  zb_BindDevice( TRUE, LIGHT_STATUS_CMD_ID, (uint8 *)NULL) ;
   \   000037                ; Setup parameters for call to function zb_BindDevice
   \   000037   7C00         MOV     R4,#0x0
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   7A04         MOV     R2,#0x4
   \                     ??zb_ReceiveDataIndication_2:
   \   00003D   7B00         MOV     R3,#0x0
   \   00003F   7901         MOV     R1,#0x1
   \   000041   12....       LCALL   `??zb_BindDevice::?relay`; Banked call to: zb_BindDevice
   \   000044   804E         SJMP    ??zb_ReceiveDataIndication_4
    455                }
    456                else{
    457                  zb_AllowBind( 0xFF );
   \                     ??zb_ReceiveDataIndication_3:
   \   000046                ; Setup parameters for call to function zb_AllowBind
   \   000046   79FF         MOV     R1,#-0x1
   \   000048   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
   \   00004B   8047         SJMP    ??zb_ReceiveDataIndication_4
    458                }
    459              }
    460            
    461            else{
    462              if(command == LOCK_CONTROL_CMD_ID){
   \                     ??zb_ReceiveDataIndication_0:
   \   00004D   7401         MOV     A,#0x1
   \   00004F   6E           XRL     A,R6
   \   000050   4F           ORL     A,R7
   \   000051   7011         JNZ     ??zb_ReceiveDataIndication_5
    463                if(*pData == 0 ){
   \   000053   E8           MOV     A,R0
   \   000054   53F37F       ANL     0xf3,#0x7f
   \   000057   7004         JNZ     ??zb_ReceiveDataIndication_6
    464                   MCU_IO_OUTPUT(0, 7, 0);
   \   000059   C287         CLR     0x80.7
   \   00005B   8002         SJMP    ??zb_ReceiveDataIndication_7
    465                } else {
    466                   MCU_IO_OUTPUT(0, 7, 1);
   \                     ??zb_ReceiveDataIndication_6:
   \   00005D   D287         SETB    0x80.7
   \                     ??zb_ReceiveDataIndication_7:
   \   00005F   43FD80       ORL     0xfd,#0x80
   \   000062   8030         SJMP    ??zb_ReceiveDataIndication_4
    467                }
    468              }
    469              
    470              else if(command == LIGHT_CONTROL_CMD_ID){
   \                     ??zb_ReceiveDataIndication_5:
   \   000064   7402         MOV     A,#0x2
   \   000066   6E           XRL     A,R6
   \   000067   4F           ORL     A,R7
   \   000068   702A         JNZ     ??zb_ReceiveDataIndication_4
    471                if(*pData == 0 ){
   \   00006A   E8           MOV     A,R0
   \   00006B   90....       MOV     DPTR,#lightState
   \   00006E   7004         JNZ     ??zb_ReceiveDataIndication_8
    472                    lightState = 0;
   \   000070   E4           CLR     A
   \   000071   F0           MOVX    @DPTR,A
   \   000072   8020         SJMP    ??zb_ReceiveDataIndication_4
    473                } else {
    474                  if(!lightState){
   \                     ??zb_ReceiveDataIndication_8:
   \   000074   E0           MOVX    A,@DPTR
   \   000075   701D         JNZ     ??zb_ReceiveDataIndication_4
    475                    lightState = 1;
   \   000077   7401         MOV     A,#0x1
   \   000079   F0           MOVX    @DPTR,A
    476                    osal_start_timerEx( sapi_TaskID, CHECK_LDR_STATUS_EVT , checkLdrStateDelay );
   \   00007A                ; Setup parameters for call to function osal_start_timerEx
   \   00007A   90....       MOV     DPTR,#checkLdrStateDelay
   \   00007D   12....       LCALL   ?Subroutine1 & 0xFFFF
    477                  }
    478                }
    479              }
    480            }
   \                     ??CrossCallReturnLabel_3:
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000083   7A02         MOV     R2,#0x2
   \   000085   7B00         MOV     R3,#0x0
   \   000087   90....       MOV     DPTR,#sapi_TaskID
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   F9           MOV     R1,A
   \   00008C   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00008F   7404         MOV     A,#0x4
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
    481          }
   \                     ??zb_ReceiveDataIndication_4:
   \   000094   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000097                REQUIRE P0SEL
   \   000097                REQUIRE _A_P0
   \   000097                REQUIRE P0DIR
    482          
    483          /******************************************************************************
    484           * @fn          uartRxCB
    485           *
    486           * @brief       Callback function for UART
    487           *
    488           * @param       port - UART port
    489           *              event - UART event that caused callback
    490           *
    491           * @return      none
    492           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    493          void uartRxCB( uint8 port, uint8 event )
   \                     uartRxCB:
    494          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 135
   \   000005   7479         MOV     A,#0x79
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    495            (void)port;
    496          
    497            uint8 pBuf[RX_BUF_LEN];
    498            uint16 cmd;
    499            uint16 len;
    500          
    501            if ( event != HAL_UART_TX_EMPTY )
   \   00000C   7410         MOV     A,#0x10
   \   00000E   6E           XRL     A,R6
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??uartRxCB_0 & 0xFFFF
    502            {
    503              // Read from UART
    504              len = HalUARTRead( HAL_UART_PORT_0, pBuf, RX_BUF_LEN );
    505          
    506              if ( len > 0 )
   \   000014                ; Setup parameters for call to function HalUARTRead
   \   000014   7C80         MOV     R4,#-0x80
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7407         MOV     A,#0x7
   \   00001A   12....       LCALL   ?XSTACK_DISP101_8
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   12....       LCALL   `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000022   8B..         MOV     ?V1,R3
   \   000024   EA           MOV     A,R2
   \   000025   45..         ORL     A,?V1
   \   000027   6071         JZ      ??uartRxCB_0
    507              {
    508                cmd = BUILD_UINT16(pBuf[SYS_PING_CMD_OFFSET + 1], pBuf[SYS_PING_CMD_OFFSET]);
    509          
    510                if( (pBuf[FRAME_SOF_OFFSET] == CPT_SOP) && (cmd == SYS_PING_REQUEST) )
   \   000029   7407         MOV     A,#0x7
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   64FE         XRL     A,#0xfe
   \   000031   7067         JNZ     ??uartRxCB_0
   \   000033   7409         MOV     A,#0x9
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   7408         MOV     A,#0x8
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   EA           MOV     A,R2
   \   000042   F8           MOV     R0,A
   \   000043   7421         MOV     A,#0x21
   \   000045   68           XRL     A,R0
   \   000046   49           ORL     A,R1
   \   000047   7051         JNZ     ??uartRxCB_0
    511                {
    512                  sysPingReqRcvd();
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   74FE         MOV     A,#-0x2
   \   000051   F0           MOVX    @DPTR,A
   \   000052   7401         MOV     A,#0x1
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7402         MOV     A,#0x2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   7461         MOV     A,#0x61
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   7401         MOV     A,#0x1
   \   000067   F0           MOVX    @DPTR,A
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   7441         MOV     A,#0x41
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   7405         MOV     A,#0x5
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E4           CLR     A
   \   000076   F0           MOVX    @DPTR,A
   \   000077   04           INC     A
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   7800         MOV     R0,#0x0
   \   00007D   7905         MOV     R1,#0x5
   \                     ??uartRxCB_1:
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C8           XCH     A,R0
   \   000081   68           XRL     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   D9F9         DJNZ    R1,??uartRxCB_1
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E8           MOV     A,R0
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D                ; Setup parameters for call to function HalUARTWrite
   \   00008D   7C07         MOV     R4,#0x7
   \   00008F   7D00         MOV     R5,#0x0
   \   000091   AA..         MOV     R2,?XSP + 0
   \   000093   AB..         MOV     R3,?XSP + 1
   \   000095   7900         MOV     R1,#0x0
   \   000097   12....       LCALL   `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    513                }
    514              }
    515            }
    516          }
   \                     ??uartRxCB_0:
   \   00009A   7487         MOV     A,#-0x79
   \   00009C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009F   7F02         MOV     R7,#0x2
   \   0000A1   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for retryStartDelay>`:
   \   000000   0A           DB 10

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for checkLockStateDelay>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for checkLdrStateDelay>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for lastKnownLockState>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for lastKnownLightState>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleOsalEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleOsalEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_StartConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_StartConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_SendDataConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_SendDataConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_BindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_BindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_AllowBindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_AllowBindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_FindDeviceConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_FindDeviceConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_ReceiveDataIndication::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??uartRxCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uartRxCB
    517          
    518          /******************************************************************************
    519           * @fn          sysPingReqRcvd
    520           *
    521           * @brief       Ping request received
    522           *
    523           * @param       none
    524           *
    525           * @return      none
    526           */
    527          static void sysPingReqRcvd(void)
    528          {
    529             sysPingRsp();
    530          }
    531          
    532          /******************************************************************************
    533           * @fn          sysPingRsp
    534           *
    535           * @brief       Build and send Ping response
    536           *
    537           * @param       none
    538           *
    539           * @return      none
    540           */
    541          static void sysPingRsp(void)
    542          {
    543            uint8 pBuf[SYS_PING_RSP_LENGTH];
    544          
    545            // Start of Frame Delimiter
    546            pBuf[FRAME_SOF_OFFSET] = CPT_SOP;
    547          
    548            // Length
    549            pBuf[FRAME_LENGTH_OFFSET] = 2;
    550          
    551            // Command type
    552            pBuf[FRAME_CMD0_OFFSET] = LO_UINT16(SYS_PING_RESPONSE);
    553            pBuf[FRAME_CMD1_OFFSET] = HI_UINT16(SYS_PING_RESPONSE);
    554          
    555            // Stack profile
    556            pBuf[FRAME_DATA_OFFSET] = LO_UINT16(STACK_PROFILE);
    557            pBuf[FRAME_DATA_OFFSET + 1] = HI_UINT16(STACK_PROFILE);
    558          
    559            // Frame Check Sequence
    560            pBuf[SYS_PING_RSP_LENGTH - 1] = calcFCS(&pBuf[FRAME_LENGTH_OFFSET], (SYS_PING_RSP_LENGTH - 2));
    561          
    562            // Write frame to UART
    563            HalUARTWrite(HAL_UART_PORT_0,pBuf, SYS_PING_RSP_LENGTH);
    564          }
    565          
    566          
    567          /******************************************************************************
    568           * @fn          calcFCS
    569           *
    570           * @brief       This function calculates the FCS checksum for the serial message
    571           *
    572           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
    573           *              len - Length of the pBuf.
    574           *
    575           * @return      The calculated FCS.
    576           ******************************************************************************
    577           */
    578          static uint8 calcFCS(uint8 *pBuf, uint8 len)
    579          {
    580            uint8 rtrn = 0;
    581          
    582            while ( len-- )
    583            {
    584              rtrn ^= *pBuf++;
    585            }
    586          
    587            return rtrn;
    588          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    145   uartRxCB
        0    145   -> HalUARTRead
        0    145   -> HalUARTWrite
      0      0   zb_AllowBindConfirm
      0     17   zb_BindConfirm
        0     13   -> HalLedSet
        0     17   -> osal_start_timerEx
        0     13   -> zb_AllowBind
      0      0   zb_FindDeviceConfirm
      0      0   zb_HandleKeys
      1     18   zb_HandleOsalEvent
        0     13   -> HalAdcRead
        0     17   -> osal_start_timerEx
        0     18   -> zb_SendDataRequest
        0     13   -> zb_StartRequest
      0     20   zb_ReceiveDataIndication
        0     16   -> osal_start_timerEx
        0     12   -> zb_AllowBind
        0     12   -> zb_BindDevice
      0      0   zb_SendDataConfirm
      0     16   zb_StartConfirm
        0     12   -> HalAdcInit
        0     12   -> HalLedSet
        0     16   -> osal_start_timerEx
        0     12   -> zb_AllowBind


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for checkLdrStateDelay>
       1  ?<Initializer for checkLockStateDelay>
       1  ?<Initializer for lastKnownLightState>
       1  ?<Initializer for lastKnownLockState>
       1  ?<Initializer for retryStartDelay>
       5  ?Subroutine0
      13  ?Subroutine1
       1  P0DIR
       1  P0INP
       1  P0SEL
       1  P2INP
       1  _A_P0
       1  appState
       1  checkLdrStateDelay
       1  checkLockStateDelay
       1  lastKnownLightState
       1  lastKnownLockState
       1  lightState
       1  retryStartDelay
     164  uartRxCB
       6  uartRxCB::?relay
       3  zb_AllowBindConfirm
       6  zb_AllowBindConfirm::?relay
      82  zb_BindConfirm
       6  zb_BindConfirm::?relay
       3  zb_FindDeviceConfirm
       6  zb_FindDeviceConfirm::?relay
       3  zb_HandleKeys
       6  zb_HandleKeys::?relay
     298  zb_HandleOsalEvent
       6  zb_HandleOsalEvent::?relay
       4  zb_InCmdList
       4  zb_OutCmdList
     151  zb_ReceiveDataIndication
       6  zb_ReceiveDataIndication::?relay
       3  zb_SendDataConfirm
       6  zb_SendDataConfirm::?relay
      12  zb_SimpleDesc
     113  zb_StartConfirm
       6  zb_StartConfirm::?relay

 
 838 bytes in segment BANKED_CODE
  54 bytes in segment BANK_RELAYS
   5 bytes in segment SFR_AN
   5 bytes in segment XDATA_I
   5 bytes in segment XDATA_ID
  20 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 897 bytes of CODE  memory
  20 bytes of CONST memory
   0 bytes of DATA  memory (+ 5 bytes shared)
   7 bytes of XDATA memory

Errors: none
Warnings: 3
