###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                15/Mar/2016  11:24:04
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
#    Command line       =  
#        -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0EEE
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
#        -D HOLD_AUTO_START -D BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D
#        xNV_RESTORE -D ZTOOL_P1 -lC
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\
#        -lA
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\Source\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Oh --require_prototypes
#    List file          =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\List\DemoCoordinator.lst
#    Object file        =  
#        C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\CC2530DB\CoordinatorEB\Obj\DemoCoordinator.r51
#
###############################################################################

C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c
      1          /**************************************************************************************************
      2            Filename:       DemoCoordinator.c
      3          
      4            Description:    Coordinator application for the sensor demo utilizing Simple API.
      5          
      6                            The collector node can be set in a state where it accepts
      7                            incoming reports from the sensor nodes, and can send the reports
      8                            via the UART to a PC tool. The collector node in this state
      9                            functions as a gateway. The collector nodes that are not in the
     10                            gateway node function as routers in the network.
     11          
     12          
     13            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15            IMPORTANT: Your use of this Software is limited to those specific rights
     16            granted under the terms of a software license agreement between the user
     17            who downloaded the software, his/her employer (which must be your employer)
     18            and Texas Instruments Incorporated (the "License").  You may not use this
     19            Software unless you agree to abide by the terms of the License. The License
     20            limits your use, and you acknowledge, that the Software may not be modified,
     21            copied or distributed unless embedded on a Texas Instruments microcontroller
     22            or used solely and exclusively in conjunction with a Texas Instruments radio
     23            frequency transceiver, which is integrated into your product.  Other than for
     24            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25            works of, modify, distribute, perform, display or sell this Software and/or
     26            its documentation for any purpose.
     27          
     28            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40            Should you have any questions regarding your right to use this Software,
     41            contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /******************************************************************************
     45           * INCLUDES
     46           */
     47          
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "sapi.h"
     52          #include "hal_key.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     53          #include "hal_led.h"
     54          #include "hal_lcd.h"
     55          #include "hal_uart.h"
     56          #include "DemoApp.h"
     57          
     58          /******************************************************************************
     59           * CONSTANTS
     60           */
     61          
     62          // General UART frame offsets
     63          #define FRAME_SOF_OFFSET                    0
     64          #define FRAME_LENGTH_OFFSET                 1
     65          #define FRAME_CMD0_OFFSET                   2
     66          #define FRAME_CMD1_OFFSET                   3
     67          #define FRAME_DATA_OFFSET                   4
     68          
     69          // ZB_RECEIVE_DATA_INDICATION offsets
     70          #define ZB_RECV_SRC_OFFSET                  0
     71          #define ZB_RECV_CMD_OFFSET                  2
     72          #define ZB_RECV_LEN_OFFSET                  4
     73          #define ZB_RECV_DATA_OFFSET                 6
     74          #define ZB_RECV_FCS_OFFSET                  8
     75          
     76          // ZB_RECEIVE_DATA_INDICATION frame length
     77          #define ZB_RECV_LENGTH                      15
     78          
     79          // PING response frame length and offset
     80          #define SYS_PING_RSP_LENGTH                 7
     81          #define SYS_PING_CMD_OFFSET                 1
     82          
     83          // Stack Profile
     84          #define ZIGBEE_2007                         0x0040
     85          #define ZIGBEE_PRO_2007                     0x0041
     86          
     87          #ifdef ZIGBEEPRO
     88          #define STACK_PROFILE                       ZIGBEE_PRO_2007
     89          #else
     90          #define STACK_PROFILE                       ZIGBEE_2007
     91          #endif
     92          
     93          #define CPT_SOP                             0xFE
     94          #define SYS_PING_REQUEST                    0x0021
     95          #define SYS_PING_RESPONSE                   0x0161
     96          #define ZB_RECEIVE_DATA_INDICATION          0x8746
     97          
     98          // Application States
     99          #define APPSTATE_INIT                       0
    100          #define APPSTATE_STARTED                    1
    101          
    102          // Application osal event identifiers
    103          #define RETRY_START_EVT                        0x0001
    104          #define CHECK_LOCK_STATUS_EVT                  0x0002
    105          
    106          /******************************************************************************
    107           * TYPEDEFS
    108           */
    109          typedef struct
    110          {
    111            uint16              source;
    112            uint16              parent;
    113            uint8               temp;
    114            uint8               voltage;
    115          } gtwData_t;
    116          
    117          /******************************************************************************
    118           * LOCAL VARIABLES
    119           */
    120          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    121          static uint8 appState = APPSTATE_INIT;
   \                     appState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    122          static uint8 retryStartDelay =    10;
   \                     retryStartDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for retryStartDelay>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
    123          static uint8 checkLockStateDelay= 255;
   \                     checkLockStateDelay:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for checkLockStateDelay>`
   \   000001                REQUIRE __INIT_XDATA_I
    124          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    125          static uint8 lastKnownLockState = 0xFF; //init waarde
   \                     lastKnownLockState:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for lastKnownLockState>`
   \   000001                REQUIRE __INIT_XDATA_I
    126          /******************************************************************************
    127           * LOCAL FUNCTIONS
    128           */
    129          
    130          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    131          static void sysPingReqRcvd(void);
    132          static void sysPingRsp(void);
    133          
    134          /******************************************************************************
    135           * GLOBAL VARIABLES
    136           */
    137          
    138          // Inputs and Outputs for Collector device
    139          #define NUM_OUT_CMD_COLLECTOR           2
    140          #define NUM_IN_CMD_COLLECTOR            2
    141          
    142          // List of output and input commands for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    143          const cId_t zb_InCmdList[NUM_IN_CMD_COLLECTOR] =
   \                     zb_InCmdList:
   \   000000   0100         DW 1
   \   000002   0200         DW 2
    144          {
    145            LOCK_CONTROL_CMD_ID,
    146            LIGHT_CONTROL_CMD_ID
    147          };

   \                                 In  segment XDATA_ROM_C, align 1
    148          const cId_t zb_OutCmdList[NUM_OUT_CMD_COLLECTOR] =
   \                     zb_OutCmdList:
   \   000000   0300         DW 3
   \   000002   0400         DW 4
    149          {
    150            LOCK_STATUS_CMD_ID,
    151            LIGHT_STATUS_CMD_ID
    152          };
    153          
    154          
    155          // Define SimpleDescriptor for Collector device

   \                                 In  segment XDATA_ROM_C, align 1
    156          const SimpleDescriptionFormat_t zb_SimpleDesc =
   \                     zb_SimpleDesc:
   \   000000   02           DB 2
   \   000001   200F         DW 3872
   \   000003   0200         DW 2
   \   000005   01           DB 1
   \   000006   02           DB 2
   \   000007   ....         DW zb_InCmdList
   \   000009   02           DB 2
   \   00000A   ....         DW zb_OutCmdList
    157          {
    158            MY_ENDPOINT_ID,             //  Endpoint
    159            MY_PROFILE_ID,              //  Profile ID
    160            DEV_ID_COLLECTOR,           //  Device ID
    161            DEVICE_VERSION_COLLECTOR,   //  Device Version
    162            0,                          //  Reserved
    163            NUM_IN_CMD_COLLECTOR,       //  Number of Input Commands
    164            (cId_t *) zb_InCmdList,     //  Input Command List
    165            NUM_OUT_CMD_COLLECTOR,      //  Number of Output Commands
    166            (cId_t *) zb_OutCmdList     //  Output Command List
    167          };
    168          
    169          /******************************************************************************
    170           * FUNCTIONS
    171           */
    172          
    173          /******************************************************************************
    174           * @fn          zb_HandleOsalEvent
    175           *
    176           * @brief       The zb_HandleOsalEvent function is called by the operating
    177           *              system when a task event is set
    178           *
    179           * @param       event - Bitmask containing the events that have been set
    180           *
    181           * @return      none
    182           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    183          void zb_HandleOsalEvent( uint16 event )
   \                     zb_HandleOsalEvent:
    184          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    185            if( event & SYS_EVENT_MSG )
    186            {
    187            }
    188          
    189            if( event & ZB_ENTRY_EVENT || event & RETRY_START_EVT  )
   \   00000E   EE           MOV     A,R6
   \   00000F   5401         ANL     A,#0x1
   \   000011   F8           MOV     R0,A
   \   000012   EF           MOV     A,R7
   \   000013   5410         ANL     A,#0x10
   \   000015   F9           MOV     R1,A
   \   000016   E8           MOV     A,R0
   \   000017   49           ORL     A,R1
   \   000018   6003         JZ      ??zb_HandleOsalEvent_0
    190            {
    191              zb_StartRequest();
   \   00001A                ; Setup parameters for call to function zb_StartRequest
   \   00001A   12....       LCALL   `??zb_StartRequest::?relay`; Banked call to: zb_StartRequest
    192            }
    193          
    194            
    195            if (event & CHECK_LOCK_STATUS_EVT ){
   \                     ??zb_HandleOsalEvent_0:
   \   00001D   EE           MOV     A,R6
   \   00001E   5402         ANL     A,#0x2
   \   000020   606C         JZ      ??zb_HandleOsalEvent_1
    196              
    197              uint8 lockState = (MCU_IO_GET(0,2) == 0);
   \   000022   A282         MOV     C,0x80.2
   \   000024   4004         JC      ??zb_HandleOsalEvent_2
   \   000026   D2F0         SETB    B.0
   \   000028   8002         SJMP    ??zb_HandleOsalEvent_3
   \                     ??zb_HandleOsalEvent_2:
   \   00002A   C2F0         CLR     B.0
   \                     ??zb_HandleOsalEvent_3:
   \   00002C   A2F0         MOV     C,B.0
   \   00002E   E4           CLR     A
   \   00002F   33           RLC     A
   \   000030   FE           MOV     R6,A
    198              
    199              if (lockState != lastKnownLockState){
   \   000031   90....       MOV     DPTR,#lastKnownLockState
   \   000034   E0           MOVX    A,@DPTR
   \   000035   6E           XRL     A,R6
   \   000036   603F         JZ      ??zb_HandleOsalEvent_4
    200                uint8 pData[LOCK_CMD_LENGTH];
    201                pData[LOCK_CMD_OFFSET] = lockState;
   \   000038   EE           MOV     A,R6
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   F0           MOVX    @DPTR,A
    202                uint8 txOptions;
    203                zb_SendDataRequest( 0xFFFE, LOCK_STATUS_CMD_ID, LOCK_CMD_LENGTH , pData, 0, txOptions, 0 );
                                                                                                   ^
Warning[Pe549]: variable "txOptions" is used before its value is set

  static uint8 appState = APPSTATE_INIT;
               ^
"C:\Users\Bart\Documents\GitHub\WTSN\Projects\zstack\Project\Eindopdracht\Source\DemoCoordinator.c",121  Warning[Pe550]: 
          variable "appState" was set but never used
   \   000040                ; Setup parameters for call to function zb_SendDataRequest
   \   000040   75..00       MOV     ?V0,#0x0
   \   000043   78..         MOV     R0,#?V0
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000048   78..         MOV     R0,#?V0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004D   78..         MOV     R0,#?V0
   \   00004F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000052   7403         MOV     A,#0x3
   \   000054   12....       LCALL   ?XSTACK_DISP100_8
   \   000057   88..         MOV     ?V0,R0
   \   000059   89..         MOV     ?V1,R1
   \   00005B   78..         MOV     R0,#?V0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   7901         MOV     R1,#0x1
   \   000062   7C03         MOV     R4,#0x3
   \   000064   7D00         MOV     R5,#0x0
   \   000066   7AFE         MOV     R2,#-0x2
   \   000068   7BFF         MOV     R3,#-0x1
   \   00006A   12....       LCALL   `??zb_SendDataRequest::?relay`; Banked call to: zb_SendDataRequest
   \   00006D   7405         MOV     A,#0x5
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
    204                lastKnownLockState = lockState;
   \   000072   EE           MOV     A,R6
   \   000073   90....       MOV     DPTR,#lastKnownLockState
   \   000076   F0           MOVX    @DPTR,A
    205              }
    206              
    207              osal_start_timerEx( sapi_TaskID, CHECK_LOCK_STATUS_EVT , checkLockStateDelay );
   \                     ??zb_HandleOsalEvent_4:
   \   000077                ; Setup parameters for call to function osal_start_timerEx
   \   000077   12....       LCALL   ?Subroutine1 & 0xFFFF
    208            }
   \                     ??CrossCallReturnLabel_1:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00007D   7A02         MOV     R2,#0x2
   \   00007F   7B00         MOV     R3,#0x0
   \   000081   90....       MOV     DPTR,#sapi_TaskID
   \   000084   E0           MOVX    A,@DPTR
   \   000085   F9           MOV     R1,A
   \   000086   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000089   7404         MOV     A,#0x4
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
    209          }
   \                     ??zb_HandleOsalEvent_1:
   \   00008E   7401         MOV     A,#0x1
   \   000090   12....       LCALL   ?DEALLOC_XSTACK8
   \   000093                REQUIRE ?Subroutine0
   \   000093                REQUIRE _A_P0
   \   000093                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   90....       MOV     DPTR,#checkLockStateDelay
   \   000003                REQUIRE ??Subroutine2_0
   \   000003                ; // Fall through to label ??Subroutine2_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   E4           CLR     A
   \   000004   F5..         MOV     ?V1,A
   \   000006   F5..         MOV     ?V2,A
   \   000008   F5..         MOV     ?V3,A
   \   00000A   78..         MOV     R0,#?V0
   \   00000C   22           RET
    210          
    211          /******************************************************************************
    212           * @fn      zb_HandleKeys
    213           *
    214           * @brief   Handles all key events for this device.
    215           *
    216           * @param   shift - true if in shift/alt.
    217           * @param   keys - bit field for key events. Valid entries:
    218           *                 EVAL_SW4
    219           *                 EVAL_SW3
    220           *                 EVAL_SW2
    221           *                 EVAL_SW1
    222           *
    223           * @return  none
    224           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    225          void zb_HandleKeys( uint8 shift, uint8 keys )
   \                     zb_HandleKeys:
    226          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    227            // Shift is used to make each button/switch dual purpose.
    228            if ( shift )
    229            {
    230              if ( keys & HAL_KEY_SW_1 )
    231              {
    232              }
    233              if ( keys & HAL_KEY_SW_2 )
    234              {
    235              }
    236              if ( keys & HAL_KEY_SW_3 )
    237              {
    238              }
    239              if ( keys & HAL_KEY_SW_4 )
    240              {
    241              }
    242            }
    243            else
    244            {
    245              if ( keys & HAL_KEY_SW_1 )
    246              {
    247              }
    248              if ( keys & HAL_KEY_SW_2 )
    249              {
    250              }
    251              if ( keys & HAL_KEY_SW_3 )
    252              {
    253              }
    254              if ( keys & HAL_KEY_SW_4 )
    255              {
    256              }
    257            }
    258          }
   \   000000   02....       LJMP    ?BRET
    259          
    260          /******************************************************************************
    261           * @fn          zb_StartConfirm
    262           *
    263           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    264           *              after a start request operation completes
    265           *
    266           * @param       status - The status of the start operation.  Status of
    267           *                       ZB_SUCCESS indicates the start operation completed
    268           *                       successfully.  Else the status is an error code.
    269           *
    270           * @return      none
    271           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    272          void zb_StartConfirm( uint8 status )
   \                     zb_StartConfirm:
    273          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    274            // If the device sucessfully started, change state to running
    275            if ( status == ZB_SUCCESS )
   \   000006   7047         JNZ     ??zb_StartConfirm_0
    276            {
    277              //init lock sensor
    278              MCU_IO_DIR_INPUT_PREP(0, 2);
   \   000008   53FDFB       ANL     0xfd,#0xfb
    279              MCU_IO_INPUT_PREP(0,2,MCU_IO_PULLDOWN);
   \   00000B   53F3FB       ANL     0xf3,#0xfb
   \   00000E   53FDFB       ANL     0xfd,#0xfb
   \   000011   538FFB       ANL     0x8f,#0xfb
   \   000014   43F720       ORL     0xf7,#0x20
    280              
    281              //init lamp
    282              MCU_IO_DIR_OUTPUT_PREP(0, 4);
   \   000017   43FD10       ORL     0xfd,#0x10
    283              MCU_IO_OUTPUT_PREP(0, 4, 0);
   \   00001A   53F3EF       ANL     0xf3,#0xef
   \   00001D   C284         CLR     0x80.4
   \   00001F   43FD10       ORL     0xfd,#0x10
    284              
    285              //init lock
    286              MCU_IO_DIR_OUTPUT_PREP(0, 7);
   \   000022   43FD80       ORL     0xfd,#0x80
    287              MCU_IO_OUTPUT_PREP(0, 7, DOOR_OPEN);
   \   000025   53F37F       ANL     0xf3,#0x7f
   \   000028   D287         SETB    0x80.7
   \   00002A   43FD80       ORL     0xfd,#0x80
    288              
    289              zb_AllowBind( 0xFF );
   \   00002D                ; Setup parameters for call to function zb_AllowBind
   \   00002D   79FF         MOV     R1,#-0x1
   \   00002F   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    290              
    291              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
   \   000032                ; Setup parameters for call to function HalLedSet
   \   000032   7A01         MOV     R2,#0x1
   \   000034   7901         MOV     R1,#0x1
   \   000036   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    292              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
   \   000039                ; Setup parameters for call to function HalLedSet
   \   000039   7A00         MOV     R2,#0x0
   \   00003B   7902         MOV     R1,#0x2
   \   00003D   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    293              HalLedSet( HAL_LED_3, HAL_LED_MODE_OFF );
   \   000040                ; Setup parameters for call to function HalLedSet
   \   000040   7A00         MOV     R2,#0x0
   \   000042   7904         MOV     R1,#0x4
   \   000044   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    294              
    295              // Change application state
    296              appState = APPSTATE_STARTED;
   \   000047   90....       MOV     DPTR,#appState
   \   00004A   7401         MOV     A,#0x1
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   801A         SJMP    ??zb_StartConfirm_1
    297            }
    298            else
    299            {
    300              // Try again later with a delay
    301              osal_start_timerEx( sapi_TaskID, RETRY_START_EVT, retryStartDelay );
   \                     ??zb_StartConfirm_0:
   \   00004F                ; Setup parameters for call to function osal_start_timerEx
   \   00004F   90....       MOV     DPTR,#retryStartDelay
   \   000052   12....       LCALL   ??Subroutine2_0 & 0xFFFF
    302            }
   \                     ??CrossCallReturnLabel_0:
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000058   7A01         MOV     R2,#0x1
   \   00005A   7B00         MOV     R3,#0x0
   \   00005C   90....       MOV     DPTR,#sapi_TaskID
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   F9           MOV     R1,A
   \   000061   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000064   7404         MOV     A,#0x4
   \   000066   12....       LCALL   ?DEALLOC_XSTACK8
    303          }
   \                     ??zb_StartConfirm_1:
   \   000069   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   00006C                REQUIRE P0DIR
   \   00006C                REQUIRE P0SEL
   \   00006C                REQUIRE P0INP
   \   00006C                REQUIRE P2INP
   \   00006C                REQUIRE _A_P0
    304          
    305          /******************************************************************************
    306           * @fn          zb_SendDataConfirm
    307           *
    308           * @brief       The zb_SendDataConfirm callback function is called by the
    309           *              ZigBee stack after a send data operation completes
    310           *
    311           * @param       handle - The handle identifying the data transmission.
    312           *              status - The status of the operation.
    313           *
    314           * @return      none
    315           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    316          void zb_SendDataConfirm( uint8 handle, uint8 status )
   \                     zb_SendDataConfirm:
    317          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    318            if (status == ZB_SUCCESS){
    319            }
    320          }
   \   000000   02....       LJMP    ?BRET
    321          
    322          /******************************************************************************
    323           * @fn          zb_BindConfirm
    324           *
    325           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    326           *              after a bind operation completes.
    327           *
    328           * @param       commandId - The command ID of the binding being confirmed.
    329           *              status - The status of the bind operation.
    330           *
    331           * @return      none
    332           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    333          void zb_BindConfirm( uint16 commandId, uint8 status )
   \                     zb_BindConfirm:
    334          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V4,R1
    335            zb_AllowBind( 0xFF );
   \   00000B                ; Setup parameters for call to function zb_AllowBind
   \   00000B   79FF         MOV     R1,#-0x1
   \   00000D   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    336            
    337            if (status == ZB_SUCCESS){
   \   000010   E5..         MOV     A,?V4
   \   000012   7033         JNZ     ??zb_BindConfirm_0
    338              if(commandId == LOCK_STATUS_CMD_ID){
   \   000014   7403         MOV     A,#0x3
   \   000016   6E           XRL     A,R6
   \   000017   4F           ORL     A,R7
   \   000018   7020         JNZ     ??zb_BindConfirm_1
    339                HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON);
   \   00001A                ; Setup parameters for call to function HalLedSet
   \   00001A   7A01         MOV     R2,#0x1
   \   00001C   7902         MOV     R1,#0x2
   \   00001E   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    340                osal_start_timerEx( sapi_TaskID, CHECK_LOCK_STATUS_EVT , checkLockStateDelay );
   \   000021                ; Setup parameters for call to function osal_start_timerEx
   \   000021   12....       LCALL   ?Subroutine1 & 0xFFFF
    341              }
   \                     ??CrossCallReturnLabel_2:
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000027   7A02         MOV     R2,#0x2
   \   000029   7B00         MOV     R3,#0x0
   \   00002B   90....       MOV     DPTR,#sapi_TaskID
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F9           MOV     R1,A
   \   000030   12....       LCALL   `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   800D         SJMP    ??zb_BindConfirm_0
    342              else if(commandId == LIGHT_STATUS_CMD_ID){
   \                     ??zb_BindConfirm_1:
   \   00003A   7404         MOV     A,#0x4
   \   00003C   6E           XRL     A,R6
   \   00003D   4F           ORL     A,R7
   \   00003E   7007         JNZ     ??zb_BindConfirm_0
    343                HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON);
   \   000040                ; Setup parameters for call to function HalLedSet
   \   000040   7A01         MOV     R2,#0x1
   \   000042   7904         MOV     R1,#0x4
   \   000044   12....       LCALL   `??HalLedSet::?relay`; Banked call to: HalLedSet
    344              }
    345            }
    346            
    347          }
   \                     ??zb_BindConfirm_0:
   \   000047   7F05         MOV     R7,#0x5
   \   000049   02....       LJMP    ?BANKED_LEAVE_XDATA
    348          
    349          /******************************************************************************
    350           * @fn          zb_AllowBindConfirm
    351           *
    352           * @brief       Indicates when another device attempted to bind to this device
    353           *
    354           * @param
    355           *
    356           * @return      none
    357           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          void zb_AllowBindConfirm( uint16 source )
   \                     zb_AllowBindConfirm:
    359          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    360            
    361          }
   \   000000   02....       LJMP    ?BRET
    362          
    363          /******************************************************************************
    364           * @fn          zb_FindDeviceConfirm
    365           *
    366           * @brief       The zb_FindDeviceConfirm callback function is called by the
    367           *              ZigBee stack when a find device operation completes.
    368           *
    369           * @param       searchType - The type of search that was performed.
    370           *              searchKey - Value that the search was executed on.
    371           *              result - The result of the search.
    372           *
    373           * @return      none
    374           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    375          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
   \                     zb_FindDeviceConfirm:
    376          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    377            (void)searchType;
    378            (void)searchKey;
    379            (void)result;
    380          }
   \   000000   02....       LJMP    ?BRET
    381          
    382          /******************************************************************************
    383           * @fn          zb_ReceiveDataIndication
    384           *
    385           * @brief       The zb_ReceiveDataIndication callback function is called
    386           *              asynchronously by the ZigBee stack to notify the application
    387           *              when data is received from a peer device.
    388           *
    389           * @param       source - The short address of the peer device that sent the data
    390           *              command - The commandId associated with the data
    391           *              len - The number of bytes in the pData parameter
    392           *              pData - The data sent by the peer device
    393           *
    394           * @return      none
    395           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    396          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
   \                     zb_ReceiveDataIndication:
    397          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   740B         MOV     A,#0xb
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   8882         MOV     DPL,R0
   \   000015   8983         MOV     DPH,R1
    398            if(*pData == IDENTIFIER_COMMAND ){
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   74F0         MOV     A,#-0x10
   \   00001B   68           XRL     A,R0
   \   00001C   702F         JNZ     ??zb_ReceiveDataIndication_0
    399                zb_AllowBind( 0x00 );
   \   00001E                ; Setup parameters for call to function zb_AllowBind
   \   00001E   7900         MOV     R1,#0x0
   \   000020   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
    400                if(command == LOCK_CONTROL_CMD_ID){
   \   000023   7401         MOV     A,#0x1
   \   000025   6E           XRL     A,R6
   \   000026   4F           ORL     A,R7
   \   000027   7008         JNZ     ??zb_ReceiveDataIndication_1
    401                  zb_BindDevice( TRUE, LOCK_STATUS_CMD_ID, (uint8 *)NULL) ;
   \   000029                ; Setup parameters for call to function zb_BindDevice
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A03         MOV     R2,#0x3
   \   00002F   800C         SJMP    ??zb_ReceiveDataIndication_2
    402                }
    403                else if(command == LIGHT_CONTROL_CMD_ID){
   \                     ??zb_ReceiveDataIndication_1:
   \   000031   7402         MOV     A,#0x2
   \   000033   6E           XRL     A,R6
   \   000034   4F           ORL     A,R7
   \   000035   700F         JNZ     ??zb_ReceiveDataIndication_3
    404                  zb_BindDevice( TRUE, LIGHT_STATUS_CMD_ID, (uint8 *)NULL) ;
   \   000037                ; Setup parameters for call to function zb_BindDevice
   \   000037   7C00         MOV     R4,#0x0
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   7A04         MOV     R2,#0x4
   \                     ??zb_ReceiveDataIndication_2:
   \   00003D   7B00         MOV     R3,#0x0
   \   00003F   7901         MOV     R1,#0x1
   \   000041   12....       LCALL   `??zb_BindDevice::?relay`; Banked call to: zb_BindDevice
   \   000044   801C         SJMP    ??zb_ReceiveDataIndication_4
    405                }
    406                else{
    407                  zb_AllowBind( 0xFF );
   \                     ??zb_ReceiveDataIndication_3:
   \   000046                ; Setup parameters for call to function zb_AllowBind
   \   000046   79FF         MOV     R1,#-0x1
   \   000048   12....       LCALL   `??zb_AllowBind::?relay`; Banked call to: zb_AllowBind
   \   00004B   8015         SJMP    ??zb_ReceiveDataIndication_4
    408                }
    409              }
    410            
    411            else{
    412              if(command == LOCK_CONTROL_CMD_ID){
   \                     ??zb_ReceiveDataIndication_0:
   \   00004D   7401         MOV     A,#0x1
   \   00004F   6E           XRL     A,R6
   \   000050   4F           ORL     A,R7
   \   000051   700F         JNZ     ??zb_ReceiveDataIndication_4
    413                if(*pData == 0 ){
   \   000053   E8           MOV     A,R0
   \   000054   53F37F       ANL     0xf3,#0x7f
   \   000057   7004         JNZ     ??zb_ReceiveDataIndication_5
    414                   MCU_IO_OUTPUT_PREP(0, 7, 0);
   \   000059   C287         CLR     0x80.7
   \   00005B   8002         SJMP    ??zb_ReceiveDataIndication_6
    415                } else {
    416                   MCU_IO_OUTPUT_PREP(0, 7, 1);
   \                     ??zb_ReceiveDataIndication_5:
   \   00005D   D287         SETB    0x80.7
   \                     ??zb_ReceiveDataIndication_6:
   \   00005F   43FD80       ORL     0xfd,#0x80
    417                }
    418              }
    419              
    420              else if(command == LIGHT_CONTROL_CMD_ID){
    421              }
    422            }
    423          }
   \                     ??zb_ReceiveDataIndication_4:
   \   000062   7F01         MOV     R7,#0x1
   \   000064   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000067                REQUIRE P0SEL
   \   000067                REQUIRE _A_P0
   \   000067                REQUIRE P0DIR
    424          
    425          /******************************************************************************
    426           * @fn          uartRxCB
    427           *
    428           * @brief       Callback function for UART
    429           *
    430           * @param       port - UART port
    431           *              event - UART event that caused callback
    432           *
    433           * @return      none
    434           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    435          void uartRxCB( uint8 port, uint8 event )
   \                     uartRxCB:
    436          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 135
   \   000005   7479         MOV     A,#0x79
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    437            (void)port;
    438          
    439            uint8 pBuf[RX_BUF_LEN];
    440            uint16 cmd;
    441            uint16 len;
    442          
    443            if ( event != HAL_UART_TX_EMPTY )
   \   00000C   7410         MOV     A,#0x10
   \   00000E   6E           XRL     A,R6
   \   00000F   7003         JNZ     $+5
   \   000011   02....       LJMP    ??uartRxCB_0 & 0xFFFF
    444            {
    445              // Read from UART
    446              len = HalUARTRead( HAL_UART_PORT_0, pBuf, RX_BUF_LEN );
    447          
    448              if ( len > 0 )
   \   000014                ; Setup parameters for call to function HalUARTRead
   \   000014   7C80         MOV     R4,#-0x80
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7407         MOV     A,#0x7
   \   00001A   12....       LCALL   ?XSTACK_DISP101_8
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   12....       LCALL   `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000022   8B..         MOV     ?V1,R3
   \   000024   EA           MOV     A,R2
   \   000025   45..         ORL     A,?V1
   \   000027   6071         JZ      ??uartRxCB_0
    449              {
    450                cmd = BUILD_UINT16(pBuf[SYS_PING_CMD_OFFSET + 1], pBuf[SYS_PING_CMD_OFFSET]);
    451          
    452                if( (pBuf[FRAME_SOF_OFFSET] == CPT_SOP) && (cmd == SYS_PING_REQUEST) )
   \   000029   7407         MOV     A,#0x7
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   64FE         XRL     A,#0xfe
   \   000031   7067         JNZ     ??uartRxCB_0
   \   000033   7409         MOV     A,#0x9
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   7408         MOV     A,#0x8
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   EA           MOV     A,R2
   \   000042   F8           MOV     R0,A
   \   000043   7421         MOV     A,#0x21
   \   000045   68           XRL     A,R0
   \   000046   49           ORL     A,R1
   \   000047   7051         JNZ     ??uartRxCB_0
    453                {
    454                  sysPingReqRcvd();
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   74FE         MOV     A,#-0x2
   \   000051   F0           MOVX    @DPTR,A
   \   000052   7401         MOV     A,#0x1
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7402         MOV     A,#0x2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   7461         MOV     A,#0x61
   \   00005F   F0           MOVX    @DPTR,A
   \   000060   7403         MOV     A,#0x3
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   7401         MOV     A,#0x1
   \   000067   F0           MOVX    @DPTR,A
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   7441         MOV     A,#0x41
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   7405         MOV     A,#0x5
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E4           CLR     A
   \   000076   F0           MOVX    @DPTR,A
   \   000077   04           INC     A
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   7800         MOV     R0,#0x0
   \   00007D   7905         MOV     R1,#0x5
   \                     ??uartRxCB_1:
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C8           XCH     A,R0
   \   000081   68           XRL     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   D9F9         DJNZ    R1,??uartRxCB_1
   \   000086   7406         MOV     A,#0x6
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   E8           MOV     A,R0
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D                ; Setup parameters for call to function HalUARTWrite
   \   00008D   7C07         MOV     R4,#0x7
   \   00008F   7D00         MOV     R5,#0x0
   \   000091   AA..         MOV     R2,?XSP + 0
   \   000093   AB..         MOV     R3,?XSP + 1
   \   000095   7900         MOV     R1,#0x0
   \   000097   12....       LCALL   `??HalUARTWrite::?relay`; Banked call to: HalUARTWrite
    455                }
    456              }
    457            }
    458          }
   \                     ??uartRxCB_0:
   \   00009A   7487         MOV     A,#-0x79
   \   00009C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009F   7F02         MOV     R7,#0x2
   \   0000A1   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for retryStartDelay>`:
   \   000000   0A           DB 10

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for checkLockStateDelay>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for lastKnownLockState>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleOsalEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleOsalEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_HandleKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_StartConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_StartConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_SendDataConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_SendDataConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_BindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_BindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_AllowBindConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_AllowBindConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_FindDeviceConfirm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_FindDeviceConfirm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zb_ReceiveDataIndication::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zb_ReceiveDataIndication

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??uartRxCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uartRxCB
    459          
    460          /******************************************************************************
    461           * @fn          sysPingReqRcvd
    462           *
    463           * @brief       Ping request received
    464           *
    465           * @param       none
    466           *
    467           * @return      none
    468           */
    469          static void sysPingReqRcvd(void)
    470          {
    471             sysPingRsp();
    472          }
    473          
    474          /******************************************************************************
    475           * @fn          sysPingRsp
    476           *
    477           * @brief       Build and send Ping response
    478           *
    479           * @param       none
    480           *
    481           * @return      none
    482           */
    483          static void sysPingRsp(void)
    484          {
    485            uint8 pBuf[SYS_PING_RSP_LENGTH];
    486          
    487            // Start of Frame Delimiter
    488            pBuf[FRAME_SOF_OFFSET] = CPT_SOP;
    489          
    490            // Length
    491            pBuf[FRAME_LENGTH_OFFSET] = 2;
    492          
    493            // Command type
    494            pBuf[FRAME_CMD0_OFFSET] = LO_UINT16(SYS_PING_RESPONSE);
    495            pBuf[FRAME_CMD1_OFFSET] = HI_UINT16(SYS_PING_RESPONSE);
    496          
    497            // Stack profile
    498            pBuf[FRAME_DATA_OFFSET] = LO_UINT16(STACK_PROFILE);
    499            pBuf[FRAME_DATA_OFFSET + 1] = HI_UINT16(STACK_PROFILE);
    500          
    501            // Frame Check Sequence
    502            pBuf[SYS_PING_RSP_LENGTH - 1] = calcFCS(&pBuf[FRAME_LENGTH_OFFSET], (SYS_PING_RSP_LENGTH - 2));
    503          
    504            // Write frame to UART
    505            HalUARTWrite(HAL_UART_PORT_0,pBuf, SYS_PING_RSP_LENGTH);
    506          }
    507          
    508          
    509          /******************************************************************************
    510           * @fn          calcFCS
    511           *
    512           * @brief       This function calculates the FCS checksum for the serial message
    513           *
    514           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
    515           *              len - Length of the pBuf.
    516           *
    517           * @return      The calculated FCS.
    518           ******************************************************************************
    519           */
    520          static uint8 calcFCS(uint8 *pBuf, uint8 len)
    521          {
    522            uint8 rtrn = 0;
    523          
    524            while ( len-- )
    525            {
    526              rtrn ^= *pBuf++;
    527            }
    528          
    529            return rtrn;
    530          }

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1    145   uartRxCB
        0    145   -> HalUARTRead
        0    145   -> HalUARTWrite
      0      0   zb_AllowBindConfirm
      0     17   zb_BindConfirm
        0     13   -> HalLedSet
        0     17   -> osal_start_timerEx
        0     13   -> zb_AllowBind
      0      0   zb_FindDeviceConfirm
      0      0   zb_HandleKeys
      1     18   zb_HandleOsalEvent
        0     17   -> osal_start_timerEx
        0     18   -> zb_SendDataRequest
        0     13   -> zb_StartRequest
      0     13   zb_ReceiveDataIndication
        0      9   -> zb_AllowBind
        0      9   -> zb_BindDevice
      0      0   zb_SendDataConfirm
      0     16   zb_StartConfirm
        0     12   -> HalLedSet
        0     16   -> osal_start_timerEx
        0     12   -> zb_AllowBind


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for checkLockStateDelay>
       1  ?<Initializer for lastKnownLockState>
       1  ?<Initializer for retryStartDelay>
      13  ??Subroutine2_0
       5  ?Subroutine0
       3  ?Subroutine1
       1  P0DIR
       1  P0INP
       1  P0SEL
       1  P2INP
       1  _A_P0
       1  appState
       1  checkLockStateDelay
       1  lastKnownLockState
       1  retryStartDelay
     164  uartRxCB
       6  uartRxCB::?relay
       3  zb_AllowBindConfirm
       6  zb_AllowBindConfirm::?relay
      76  zb_BindConfirm
       6  zb_BindConfirm::?relay
       3  zb_FindDeviceConfirm
       6  zb_FindDeviceConfirm::?relay
       3  zb_HandleKeys
       6  zb_HandleKeys::?relay
     147  zb_HandleOsalEvent
       6  zb_HandleOsalEvent::?relay
       4  zb_InCmdList
       4  zb_OutCmdList
     103  zb_ReceiveDataIndication
       6  zb_ReceiveDataIndication::?relay
       3  zb_SendDataConfirm
       6  zb_SendDataConfirm::?relay
      12  zb_SimpleDesc
     108  zb_StartConfirm
       6  zb_StartConfirm::?relay

 
 631 bytes in segment BANKED_CODE
  54 bytes in segment BANK_RELAYS
   5 bytes in segment SFR_AN
   3 bytes in segment XDATA_I
   3 bytes in segment XDATA_ID
  20 bytes in segment XDATA_ROM_C
   1 byte  in segment XDATA_Z
 
 688 bytes of CODE  memory
  20 bytes of CONST memory
   0 bytes of DATA  memory (+ 5 bytes shared)
   4 bytes of XDATA memory

Errors: none
Warnings: 2
