###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                16/Feb/2016  09:50:02
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  near
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\source\sb_main.c
#    Command line       =  
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\source\sb_main.c"
#        -D HAL_SB_BOOT_CODE -D HAL_UART_SPI=2 -D
#        LOCK_THE_BOOT_IMAGE_PAGES_IN_HEX_FILE -D SBL_WAIT_TIME=60 -D
#        NO_WD_RESET_FOR_BOOTLOADER -lC "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\CC2530ZNP\List\"
#        -lA "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\CC2530ZNP\List\" -o
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\CC2530ZNP\Obj\" -e
#        --debug --core=plain --dptr=16,1 --data_model=large --code_model=near
#        --calling_convention=xdata_reentrant --place_constants=data
#        --nr_virtual_regs 16 -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\..\Source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\"
#        -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\..\..\..\..\..\COMPONENTS\HAL\TARGET\_COMMON\CC2530\"
#        -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530ZNP\"
#        -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\"
#        -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\" -Ohz
#        --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\CC2530ZNP\List\sb_main.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Mesh
#        1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\CC2530ZNP\Obj\sb_main.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0\Projects\zstack\Utilities\BootLoad\CC2530ZNP\source\sb_main.c
      1          /**************************************************************************************************
      2            Filename:       sb_main.c
      3            Revised:        $Date: 2014-08-04 15:38:03 -0700 (Mon, 04 Aug 2014) $
      4            Revision:       $Revision: 39653 $
      5          
      6            Description:    This module contains the main functionality of a Boot Loader for CC2530ZNP.
      7                            It is a minimal subset of functionality from ZMain.c, OnBoard.c and various
      8                            _hal_X.c modules for the CC2530ZNP build.
      9          
     10          
     11            Copyright 2010-2014 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License"). You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product. Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "comdef.h"
     48          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa0
   \   union <unnamed> volatile __sfr _A_P2
   \                     _A_P2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc4
   \   unsigned char volatile __sfr U0UCR
   \                     U0UCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr DMA0CFGL
   \                     DMA0CFGL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd5
   \   unsigned char volatile __sfr DMA0CFGH
   \                     DMA0CFGH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf1
   \   unsigned char volatile __sfr PERCFG
   \                     PERCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr P2INP
   \                     P2INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf8
   \   union <unnamed> volatile __sfr _A_U1CSR
   \                     _A_U1CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf9
   \   unsigned char volatile __sfr U1DBUF
   \                     U1DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfc
   \   unsigned char volatile __sfr U1GCR
   \                     U1GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xff
   \   unsigned char volatile __sfr P2DIR
   \                     P2DIR:
   \   000000                DS 1
     49          #include "hal_adc.h"
     50          #include "hal_dma.h"
     51          #include "hal_flash.h"
     52          #include "hal_types.h"
     53          #include "sb_exec_v2.h"
     54          #include "sb_main.h"
     55          #include "sb_shared.h"
     56          
     57          /* ------------------------------------------------------------------------------------------------
     58           *                                          Constants
     59           * ------------------------------------------------------------------------------------------------
     60           */
     61          
     62          // The IAR C-Stack initializer value: 0xCD.
     63          #if !defined SB_STACK_VALUE
     64          #define SB_STACK_VALUE  0xCD
     65          #endif
     66          // Not zero and not SB_STACK_VALUE.
     67          #if !defined SB_MAGIC_VALUE
     68          #define SB_MAGIC_VALUE  0xF5
     69          #endif
     70          
     71          // Reset bit definitions
     72          #define LRESET     0x18  // Last reset bit mask
     73          #define RESETPO    0x00  // Power-On reset
     74          #define RESETEX    0x08  // External reset
     75          #define RESETWD    0x10  // WatchDog reset
     76          
     77          #ifdef LOCK_THE_BOOT_IMAGE_PAGES_IN_HEX_FILE
     78          #warning LOCK_THE_BOOT_IMAGE_PAGES_IN_HEX_FILE is enabled - please see comments in code
                  ^
Warning[Pe1105]: #warning directive: LOCK_THE_BOOT_IMAGE_PAGES_IN_HEX_FILE is
          enabled - please see comments in code
     79          /* comments:
     80              Do not enable this when programming via IAR. Since not using the banked model for the boot project,
     81              when programming from IAR it will wrongly write the following value to 0x27FF0 rather than to 0x3FFF0.
     82              The lockbits are already cleared properly when programming with IAR, via Project->Options->Debugger
     83              /Texas Instruments->Flash lock protection (this does not apply for the generated hex image).
     84              Also note that the definition of _LOCKBITS_START in the linker file (xcl) is currently set for
     85              a 256k device (0x3FFF0). It has to be changed for devices with different flash size.
     86          */
     87          #pragma location="LOCKBITS"

   \                                 In  segment LOCKBITS, align 1, root
     88          __root const uint8 CODE boot_image_lockbits = 0xF0; //mark the boot image pages as "read only"
   \                     boot_image_lockbits:
   \   000000   F0           DB 240
     89          #endif
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                       Global Variables
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     96          halDMADesc_t dmaCh0;
   \                     dmaCh0:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     97          
     98          /* ------------------------------------------------------------------------------------------------
     99           *                                       Local Variables
    100           * ------------------------------------------------------------------------------------------------
    101           */
    102          
    103          /* ISR's implemented in the boot loader must be able to quickly determine whether to jump to the
    104           * boot code handlers or the run code handlers. So mark the bottom of the C call stack space with
    105           * a special value. Since the boot code linker file starts the C call stack space one byte higher
    106           * than the run code, the IAR generated initialization code does not initialize this byte;
    107           * but the boot code does - marking it with the magic value.
    108           */
    109          #pragma location="SB_MAGIC_SPACE"

   \                                 In  segment SB_MAGIC_SPACE, align 1
    110          volatile __no_init uint8 magicByte;
   \                     magicByte:
   \   000000                DS 1

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          uint8 znpCfg1;
   \                     znpCfg1:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    112          static uint8 spiPoll;
   \                     spiPoll:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          uint8 sbStateReportingEnabled = FALSE;
   \                     sbStateReportingEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    114          
    115          /* ------------------------------------------------------------------------------------------------
    116           *                                       Local Functions
    117           * ------------------------------------------------------------------------------------------------
    118           */
    119          
    120          void vddWait(uint8 vdd);
    121          static void sblInit(void);
    122          static void sblExec(void);
    123          static uint8 sblWait(uint16 sbl_wait_time);
    124          
    125          // Saving code space by not using the _hal_uart.c API and directly including the low level drivers.
    126          #include "_hal_uart_isr.c"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   static uartISRCfg_t isrCfg
   \                     isrCfg:
   \   000000                DS 265
   \   000109                REQUIRE __INIT_XDATA_Z

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant uint16 HalUARTReadISR(uint8 *, uint16)
   \                     HalUARTReadISR:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
   \   000009   8022         SJMP    ??HalUARTReadISR_0
   \                     ??HalUARTReadISR_1:
   \   00000B   74..         MOV     A,#isrCfg & 0xff
   \   00000D   2E           ADD     A,R6
   \   00000E   F582         MOV     DPL,A
   \   000010   E4           CLR     A
   \   000011   34..         ADDC    A,#(isrCfg >> 8) & 0xff
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   8A82         MOV     DPL,R2
   \   000018   8B83         MOV     DPH,R3
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   90....       MOV     DPTR,#isrCfg + 128
   \   00001E   12....       LCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_0:
   \   000021   4005         JC      ??HalUARTReadISR_2
   \   000023   90....       MOV     DPTR,#isrCfg + 128
   \   000026   E4           CLR     A
   \   000027   F0           MOVX    @DPTR,A
   \                     ??HalUARTReadISR_2:
   \   000028   08           INC     R0
   \   000029   E8           MOV     A,R0
   \   00002A   7001         JNZ     ??HalUARTReadISR_0
   \   00002C   09           INC     R1
   \                     ??HalUARTReadISR_0:
   \   00002D   90....       MOV     DPTR,#isrCfg + 128
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FE           MOV     R6,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6E           XRL     A,R6
   \   000035   6007         JZ      ??HalUARTReadISR_3
   \   000037   C3           CLR     C
   \   000038   E8           MOV     A,R0
   \   000039   9C           SUBB    A,R4
   \   00003A   E9           MOV     A,R1
   \   00003B   9D           SUBB    A,R5
   \   00003C   40CD         JC      ??HalUARTReadISR_1
   \                     ??HalUARTReadISR_3:
   \   00003E                REQUIRE ?Subroutine0
   \   00003E                ; // Fall through to label ?Subroutine0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E8           MOV     A,R0
   \   000001   FA           MOV     R2,A
   \   000002   E9           MOV     A,R1
   \   000003   FB           MOV     R3,A
   \   000004                REQUIRE ??Subroutine10_0
   \   000004                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   04           INC     A
   \   000002   12....       LCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_12:
   \   000005   C3           CLR     C
   \   000006   9480         SUBB    A,#-0x80
   \   000008   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   AA82         MOV     R2,DPL
   \   000008   AB83         MOV     R3,DPH
   \   00000A   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant uint16 HalUARTWriteISR(uint8 *, uint16)
   \                     HalUARTWriteISR:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   90....       MOV     DPTR,#isrCfg + 260
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F5..         MOV     ?V1,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F5..         MOV     ?V0,A
   \   00000F   F8           MOV     R0,A
   \   000010   E5..         MOV     A,?V1
   \   000012   C3           CLR     C
   \   000013   98           SUBB    A,R0
   \   000014   F8           MOV     R0,A
   \   000015   95E0         SUBB    A,0xE0 /* A   */
   \   000017   F9           MOV     R1,A
   \   000018   E5..         MOV     A,?V0
   \   00001A   C3           CLR     C
   \   00001B   95..         SUBB    A,?V1
   \   00001D   E8           MOV     A,R0
   \   00001E   500B         JNC     ??HalUARTWriteISR_0
   \   000020   12....       LCALL   ??Subroutine11_0
   \                     ??CrossCallReturnLabel_14:
   \   000023   7011         JNZ     ??HalUARTWriteISR_1
   \                     ??HalUARTWriteISR_2:
   \   000025   7800         MOV     R0,#0x0
   \   000027   7900         MOV     R1,#0x0
   \   000029   801B         SJMP    ??HalUARTWriteISR_3
   \                     ??HalUARTWriteISR_0:
   \   00002B   247F         ADD     A,#0x7f
   \   00002D   5001         JNC     ??HalUARTWriteISR_4
   \   00002F   09           INC     R1
   \                     ??HalUARTWriteISR_4:
   \   000030   C3           CLR     C
   \   000031   9C           SUBB    A,R4
   \   000032   E9           MOV     A,R1
   \   000033   9D           SUBB    A,R5
   \   000034   50EF         JNC     ??HalUARTWriteISR_2
   \                     ??HalUARTWriteISR_1:
   \   000036   7A00         MOV     R2,#0x0
   \   000038   7B00         MOV     R3,#0x0
   \   00003A   8041         SJMP    ??HalUARTWriteISR_5
   \                     ??HalUARTWriteISR_6:
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   04           INC     A
   \                     ??HalUARTWriteISR_7:
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   D2E9         SETB    0xe8.1
   \   000041   08           INC     R0
   \   000042   E8           MOV     A,R0
   \   000043   7001         JNZ     ??HalUARTWriteISR_3
   \   000045   09           INC     R1
   \                     ??HalUARTWriteISR_3:
   \   000046   C3           CLR     C
   \   000047   E8           MOV     A,R0
   \   000048   9C           SUBB    A,R4
   \   000049   E9           MOV     A,R1
   \   00004A   9D           SUBB    A,R5
   \   00004B   502C         JNC     ??HalUARTWriteISR_8
   \   00004D   8A82         MOV     DPL,R2
   \   00004F   8B83         MOV     DPH,R3
   \   000051   E0           MOVX    A,@DPTR
   \   000052   C0E0         PUSH    A
   \   000054   90....       MOV     DPTR,#isrCfg + 261
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FE           MOV     R6,A
   \   000059   74..         MOV     A,#(isrCfg + 132) & 0xff
   \   00005B   2E           ADD     A,R6
   \   00005C   F582         MOV     DPL,A
   \   00005E   E4           CLR     A
   \   00005F   34..         ADDC    A,#((isrCfg + 132) >> 8) & 0xff
   \   000061   F583         MOV     DPH,A
   \   000063   D0E0         POP     A
   \   000065   12....       LCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_10:
   \   000068   90....       MOV     DPTR,#isrCfg + 262
   \   00006B   E4           CLR     A
   \   00006C   F0           MOVX    @DPTR,A
   \   00006D   90....       MOV     DPTR,#isrCfg + 261
   \   000070   E0           MOVX    A,@DPTR
   \   000071   C3           CLR     C
   \   000072   947F         SUBB    A,#0x7f
   \   000074   40C6         JC      ??HalUARTWriteISR_6
   \   000076   E4           CLR     A
   \   000077   80C5         SJMP    ??HalUARTWriteISR_7
   \                     ??HalUARTWriteISR_8:
   \   000079   E8           MOV     A,R0
   \   00007A   FA           MOV     R2,A
   \   00007B   E9           MOV     A,R1
   \   00007C   FB           MOV     R3,A
   \                     ??HalUARTWriteISR_5:
   \   00007D   7F02         MOV     R7,#0x2
   \   00007F   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   000082                REQUIRE _A_IRCON2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_13:
   \   000003   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   24FF         ADD     A,#-0x1
   \   000002   18           DEC     R0
   \   000003   E9           MOV     A,R1
   \   000004   34FF         ADDC    A,#-0x1
   \   000006   F9           MOV     R1,A
   \   000007   E8           MOV     A,R0
   \   000008   49           ORL     A,R1
   \   000009   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   static __near_func __xdata_reentrant void halUartTxIsr(void)
   \                     halUartTxIsr:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   C2E9         CLR     0xe8.1
   \   000006   90....       MOV     DPTR,#isrCfg + 260
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   68           XRL     A,R0
   \   00000E   6017         JZ      ??halUartTxIsr_0
   \   000010   74..         MOV     A,#(isrCfg + 132) & 0xff
   \   000012   28           ADD     A,R0
   \   000013   F582         MOV     DPL,A
   \   000015   E4           CLR     A
   \   000016   34..         ADDC    A,#((isrCfg + 132) >> 8) & 0xff
   \   000018   F583         MOV     DPH,A
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F5C1         MOV     0xc1,A
   \   00001D   90....       MOV     DPTR,#isrCfg + 260
   \   000020   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_2:
   \   000023   4002         JC      ??halUartTxIsr_0
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   \                     ??halUartTxIsr_0:
   \   000027   02....       LJMP    ?Subroutine1
   \   00002A                REQUIRE _A_IRCON2
   \   00002A                REQUIRE U0DBUF

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   04           INC     A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   C3           CLR     C
   \   000004   9480         SUBB    A,#-0x80
   \   000006   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   22           RET
    127          #include "_hal_uart_spi.c"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   static uartSPICfg_t spiCfg
   \                     spiCfg:
   \   000000                DS 260
   \   000104                REQUIRE __INIT_XDATA_Z

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant uint16 HalUARTReadSPI(uint8 *, uint16)
   \                     HalUARTReadSPI:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   7800         MOV     R0,#0x0
   \   000007   7900         MOV     R1,#0x0
   \   000009   90....       MOV     DPTR,#spiCfg + 128
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7055         JNZ     ??HalUARTReadSPI_0
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   7051         JNZ     ??HalUARTReadSPI_0
   \   000013   75F900       MOV     0xf9,#0x0
   \   000016   C28F         CLR     0x88.7
   \   000018   C284         CLR     0x80.4
   \                     ??HalUARTReadSPI_1:
   \   00001A   A283         MOV     C,0x80.3
   \   00001C   40FC         JC      ??HalUARTReadSPI_1
   \                     ??HalUARTReadSPI_2:
   \   00001E   A28F         MOV     C,0x88.7
   \   000020   4004         JC      ??HalUARTReadSPI_3
   \   000022   A283         MOV     C,0x80.3
   \   000024   50F8         JNC     ??HalUARTReadSPI_2
   \                     ??HalUARTReadSPI_3:
   \   000026   AEF9         MOV     R6,0xf9+0x0
   \   000028   C28F         CLR     0x88.7
   \   00002A   A283         MOV     C,0x80.3
   \   00002C   5004         JNC     ??HalUARTReadSPI_4
   \   00002E   D284         SETB    0x80.4
   \   000030   8032         SJMP    ??HalUARTReadSPI_0
   \                     ??HalUARTReadSPI_4:
   \   000032   EE           MOV     A,R6
   \   000033   C0E0         PUSH    A
   \   000035   E0           MOVX    A,@DPTR
   \   000036   FE           MOV     R6,A
   \   000037   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_8:
   \   00003A   D0E0         POP     A
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   90....       MOV     DPTR,#spiCfg + 129
   \   000040   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_3:
   \   000043   40D9         JC      ??HalUARTReadSPI_2
   \   000045   E4           CLR     A
   \   000046   F0           MOVX    @DPTR,A
   \   000047   80D5         SJMP    ??HalUARTReadSPI_2
   \                     ??HalUARTReadSPI_5:
   \   000049   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_9:
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   8A82         MOV     DPL,R2
   \   00004F   8B83         MOV     DPH,R3
   \   000051   F0           MOVX    @DPTR,A
   \   000052   90....       MOV     DPTR,#spiCfg + 128
   \   000055   12....       LCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_1:
   \   000058   4005         JC      ??HalUARTReadSPI_6
   \   00005A   90....       MOV     DPTR,#spiCfg + 128
   \   00005D   E4           CLR     A
   \   00005E   F0           MOVX    @DPTR,A
   \                     ??HalUARTReadSPI_6:
   \   00005F   08           INC     R0
   \   000060   E8           MOV     A,R0
   \   000061   7001         JNZ     ??HalUARTReadSPI_0
   \   000063   09           INC     R1
   \                     ??HalUARTReadSPI_0:
   \   000064   90....       MOV     DPTR,#spiCfg + 128
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FE           MOV     R6,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   6E           XRL     A,R6
   \   00006C   6007         JZ      ??HalUARTReadSPI_7
   \   00006E   C3           CLR     C
   \   00006F   E8           MOV     A,R0
   \   000070   9C           SUBB    A,R4
   \   000071   E9           MOV     A,R1
   \   000072   9D           SUBB    A,R5
   \   000073   40D4         JC      ??HalUARTReadSPI_5
   \                     ??HalUARTReadSPI_7:
   \   000075   E8           MOV     A,R0
   \   000076   49           ORL     A,R1
   \   000077   7006         JNZ     ??HalUARTReadSPI_8
   \   000079   E4           CLR     A
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   90....       MOV     DPTR,#spiCfg + 128
   \   00007E   F0           MOVX    @DPTR,A
   \                     ??HalUARTReadSPI_8:
   \   00007F   02....       LJMP    ?Subroutine0
   \   000082                REQUIRE U1DBUF
   \   000082                REQUIRE _A_TCON
   \   000082                REQUIRE _A_P0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   74..         MOV     A,#spiCfg & 0xff
   \   000002   2E           ADD     A,R6
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   34..         ADDC    A,#(spiCfg >> 8) & 0xff
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant uint16 HalUARTWriteSPI(uint8 *, uint16)
   \                     HalUARTWriteSPI:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   90....       MOV     DPTR,#spiCfg + 259
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FE           MOV     R6,A
   \   00000A   F8           MOV     R0,A
   \   00000B   90....       MOV     DPTR,#spiCfg + 258
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FF           MOV     R7,A
   \   000010   EE           MOV     A,R6
   \   000011   C3           CLR     C
   \   000012   9F           SUBB    A,R7
   \   000013   E0           MOVX    A,@DPTR
   \   000014   500D         JNC     ??HalUARTWriteSPI_0
   \   000016   C3           CLR     C
   \   000017   98           SUBB    A,R0
   \   000018   F8           MOV     R0,A
   \   000019   95E0         SUBB    A,0xE0 /* A   */
   \   00001B   F9           MOV     R1,A
   \   00001C   12....       LCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_15:
   \   00001F   7018         JNZ     ??HalUARTWriteSPI_1
   \   000021   8012         SJMP    ??HalUARTWriteSPI_2
   \                     ??HalUARTWriteSPI_0:
   \   000023   C3           CLR     C
   \   000024   98           SUBB    A,R0
   \   000025   F8           MOV     R0,A
   \   000026   95E0         SUBB    A,0xE0 /* A   */
   \   000028   F9           MOV     R1,A
   \   000029   E8           MOV     A,R0
   \   00002A   247F         ADD     A,#0x7f
   \   00002C   5001         JNC     ??HalUARTWriteSPI_3
   \   00002E   09           INC     R1
   \                     ??HalUARTWriteSPI_3:
   \   00002F   C3           CLR     C
   \   000030   9C           SUBB    A,R4
   \   000031   E9           MOV     A,R1
   \   000032   9D           SUBB    A,R5
   \   000033   4004         JC      ??HalUARTWriteSPI_1
   \                     ??HalUARTWriteSPI_2:
   \   000035   EC           MOV     A,R4
   \   000036   4D           ORL     A,R5
   \   000037   7007         JNZ     ??HalUARTWriteSPI_4
   \                     ??HalUARTWriteSPI_1:
   \   000039   7A00         MOV     R2,#0x0
   \   00003B   7B00         MOV     R3,#0x0
   \   00003D   02....       LJMP    ??HalUARTWriteSPI_5
   \                     ??HalUARTWriteSPI_4:
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5F9         MOV     0xf9,A
   \   000047   A3           INC     DPTR
   \   000048   AA82         MOV     R2,DPL
   \   00004A   AB83         MOV     R3,DPH
   \   00004C   7801         MOV     R0,#0x1
   \   00004E   7900         MOV     R1,#0x0
   \   000050   8008         SJMP    ??HalUARTWriteSPI_6
   \                     ??HalUARTWriteSPI_7:
   \   000052   E0           MOVX    A,@DPTR
   \   000053   04           INC     A
   \                     ??HalUARTWriteSPI_8:
   \   000054   F0           MOVX    @DPTR,A
   \   000055   08           INC     R0
   \   000056   E8           MOV     A,R0
   \   000057   7001         JNZ     ??HalUARTWriteSPI_6
   \   000059   09           INC     R1
   \                     ??HalUARTWriteSPI_6:
   \   00005A   C3           CLR     C
   \   00005B   E8           MOV     A,R0
   \   00005C   9C           SUBB    A,R4
   \   00005D   E9           MOV     A,R1
   \   00005E   9D           SUBB    A,R5
   \   00005F   5027         JNC     ??HalUARTWriteSPI_9
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   E0           MOVX    A,@DPTR
   \   000066   C0E0         PUSH    A
   \   000068   90....       MOV     DPTR,#spiCfg + 259
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   FE           MOV     R6,A
   \   00006D   74..         MOV     A,#(spiCfg + 130) & 0xff
   \   00006F   2E           ADD     A,R6
   \   000070   F582         MOV     DPL,A
   \   000072   E4           CLR     A
   \   000073   34..         ADDC    A,#((spiCfg + 130) >> 8) & 0xff
   \   000075   F583         MOV     DPH,A
   \   000077   D0E0         POP     A
   \   000079   12....       LCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_11:
   \   00007C   90....       MOV     DPTR,#spiCfg + 259
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   C3           CLR     C
   \   000081   947F         SUBB    A,#0x7f
   \   000083   40CD         JC      ??HalUARTWriteSPI_7
   \   000085   E4           CLR     A
   \   000086   80CC         SJMP    ??HalUARTWriteSPI_8
   \                     ??HalUARTWriteSPI_9:
   \   000088   C28F         CLR     0x88.7
   \                     ??HalUARTWriteSPI_10:
   \   00008A   A283         MOV     C,0x80.3
   \   00008C   40FC         JC      ??HalUARTWriteSPI_10
   \   00008E   C284         CLR     0x80.4
   \                     ??HalUARTWriteSPI_11:
   \   000090   A28F         MOV     C,0x88.7
   \   000092   4004         JC      ??HalUARTWriteSPI_12
   \   000094   A283         MOV     C,0x80.3
   \   000096   50F8         JNC     ??HalUARTWriteSPI_11
   \                     ??HalUARTWriteSPI_12:
   \   000098   90....       MOV     DPTR,#spiCfg + 258
   \   00009B   12....       LCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_6:
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   F5F9         MOV     0xf9,A
   \   0000A1   C28F         CLR     0x88.7
   \   0000A3   90....       MOV     DPTR,#spiCfg + 258
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   FA           MOV     R2,A
   \   0000A8   A3           INC     DPTR
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   6A           XRL     A,R2
   \   0000AB   90....       MOV     DPTR,#spiCfg + 258
   \   0000AE   7005         JNZ     ??HalUARTWriteSPI_13
   \   0000B0   12....       LCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_7:
   \   0000B3   8005         SJMP    ??HalUARTWriteSPI_14
   \                     ??HalUARTWriteSPI_13:
   \   0000B5   12....       LCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_4:
   \   0000B8   4002         JC      ??HalUARTWriteSPI_15
   \                     ??HalUARTWriteSPI_14:
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   \                     ??HalUARTWriteSPI_15:
   \   0000BC   A283         MOV     C,0x80.3
   \   0000BE   50D0         JNC     ??HalUARTWriteSPI_11
   \   0000C0   D284         SETB    0x80.4
   \   0000C2   E8           MOV     A,R0
   \   0000C3   FA           MOV     R2,A
   \   0000C4   E9           MOV     A,R1
   \   0000C5   FB           MOV     R3,A
   \                     ??HalUARTWriteSPI_5:
   \   0000C6   02....       LJMP    ??Subroutine10_0
   \   0000C9                REQUIRE U1DBUF
   \   0000C9                REQUIRE _A_TCON
   \   0000C9                REQUIRE _A_P0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine11_0
   \   000001                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   74..         MOV     A,#(spiCfg + 130) & 0xff
   \   000004   2A           ADD     A,R2
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   34..         ADDC    A,#((spiCfg + 130) >> 8) & 0xff
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET
    128          
    129          /**************************************************************************************************
    130           * @fn          main
    131           *
    132           * @brief       ISR for the reset vector.
    133           *
    134           * input parameters
    135           *
    136           * None.
    137           *
    138           * output parameters
    139           *
    140           * None.
    141           *
    142           * @return      None.
    143           **************************************************************************************************
    144           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    145          void main(void)
   \                     main:
    146          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                ; Auto size: 5
   \   000000   74FB         MOV     A,#-0x5
   \   000002   12....       LCALL   ?ALLOC_XSTACK8
    147            uint8 time_spent_validating;
    148            uint8 bootloaderForcedByMainApp = FALSE;
   \   000005   C2..         CLR     ?VB.0
    149            uint32 mainAppCommandLocal = mainAppCommand;
   \   000007   90....       MOV     DPTR,#mainAppCommand
   \   00000A   78..         MOV     R0,#?V0
   \   00000C   12....       LCALL   ?L_MOV_X
    150          
    151            mainAppCommand = MAIN_APP_CMD_NONE;
   \   00000F   90....       MOV     DPTR,#mainAppCommand
   \   000012   7401         MOV     A,#0x1
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   7469         MOV     A,#0x69
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   74A5         MOV     A,#-0x5b
   \   00001E   F0           MOVX    @DPTR,A
    152              
    153            if (mainAppCommandLocal == MAIN_APP_CMD_FORCE_BOOTLOADER)
   \   00001F   90....       MOV     DPTR,#__Constant_a5690303
   \   000022   78..         MOV     R0,#?V0
   \   000024   12....       LCALL   ?L_EQ_X
   \   000027   7004         JNZ     ??main_0
    154            {
    155              bootloaderForcedByMainApp = TRUE;
   \   000029   D2..         SETB    ?VB.0
   \   00002B   8015         SJMP    ??main_1
    156            }
    157            else if ((mainAppCommandLocal == MAIN_APP_CMD_PASS_THROUGH) || ((SLEEPSTA & LRESET) == RESETWD))
   \                     ??main_0:
   \   00002D   90....       MOV     DPTR,#__Constant_a5690202
   \   000030   78..         MOV     R0,#?V0
   \   000032   12....       LCALL   ?L_EQ_X
   \   000035   6008         JZ      ??main_2
   \   000037   E59D         MOV     A,0x9d
   \   000039   5418         ANL     A,#0x18
   \   00003B   6410         XRL     A,#0x10
   \   00003D   7003         JNZ     ??main_1
    158            /* If reset due to WatchDog Timer - Transfer control to the main application immediately.
    159               WatchDog Timer reset causes the hardware to disconnect the USB. Without this jump here,
    160               the SBL code will try to initiaize the CDC too early, which causes undesired behavior
    161               on the host (e.g. on beaglebone black - the host gets stuck) */
    162            {
    163              asm("LJMP 0x2000\n");
   \                     ??main_2:
   \   00003F   022000       LJMP 0x2000
    164            }
    165          
    166            sblInit();
   \                     ??main_1:
   \   000042                ; Setup parameters for call to function sblInit
   \   000042   12....       LCALL   sblInit
    167          
    168            if ((!bootloaderForcedByMainApp) && sbImgValid(&time_spent_validating))
   \   000045   A2..         MOV     C,?VB.0
   \   000047   5003         JNC     $+5
   \   000049   02....       LJMP    ??main_3
   \   00004C                ; Setup parameters for call to function sbImgValid
   \   00004C   AA..         MOV     R2,?XSP + 0
   \   00004E   AB..         MOV     R3,?XSP + 1
   \   000050   12....       LCALL   sbImgValid
   \   000053   E9           MOV     A,R1
   \   000054   7003         JNZ     $+5
   \   000056   02....       LJMP    ??main_3
    169            {
    170              if (sblWait(SBL_WAIT_TIME > time_spent_validating ? SBL_WAIT_TIME - time_spent_validating : 0))
   \   000059   85..82       MOV     DPL,?XSP + 0
   \   00005C   85..83       MOV     DPH,?XSP + 1
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   C3           CLR     C
   \   000061   943C         SUBB    A,#0x3c
   \   000063   500C         JNC     ??main_4
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F8           MOV     R0,A
   \   000067   743C         MOV     A,#0x3c
   \   000069   C3           CLR     C
   \   00006A   98           SUBB    A,R0
   \   00006B   FA           MOV     R2,A
   \   00006C   95E0         SUBB    A,0xE0 /* A   */
   \   00006E   FB           MOV     R3,A
   \   00006F   8004         SJMP    ??main_5
   \                     ??main_4:
   \   000071   7A00         MOV     R2,#0x0
   \   000073   7B00         MOV     R3,#0x0
   \                     ??main_5:
   \   000075                ; Setup parameters for call to function sblWait
   \   000075   12....       LCALL   sblWait
   \   000078   E9           MOV     A,R1
   \   000079   7003         JNZ     $+5
   \   00007B   02....       LJMP    ??main_3
    171              {
    172                if (znpCfg1 == ZNP_CFG1_SPI)
   \   00007E   90....       MOV     DPTR,#znpCfg1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   6401         XRL     A,#0x1
   \   000084   700C         JNZ     ??main_6
    173                {
    174                  HalUARTUnInitSPI();
   \   000086   75F800       MOV     0xf8,#0x0
   \   000089   C2AB         CLR     0xa8.3
   \   00008B   539AF7       ANL     0x9a,#0xf7
   \   00008E   D2EA         SETB    0xe8.2
    175                }
   \   000090   805E         SJMP    ??main_7
    176                else
    177                {
    178                  sbReportState(SB_STATE_EXECUTING_IMAGE);
   \                     ??main_6:
   \   000092                ; Setup parameters for call to function sbReportState
   \   000092   7907         MOV     R1,#0x7
   \   000094   12....       LCALL   sbReportState
   \   000097   8003         SJMP    ??main_8
    179          		
    180                  while(sblIsUartTxPending())
    181                  {
    182                    sbUartPoll();
   \                     ??main_9:
   \   000099                ; Setup parameters for call to function sbUartPoll
   \   000099   12....       LCALL   sbUartPoll
    183                  }
   \                     ??main_8:
   \   00009C                ; Setup parameters for call to function sblIsUartTxPending
   \   00009C   12....       LCALL   sblIsUartTxPending
   \   00009F   E9           MOV     A,R1
   \   0000A0   70F7         JNZ     ??main_9
    184                  
    185                  SLEEP(0x2600); //Give the last bytes in the HW TX fifo (if any) enough time to be transmitted
   \   0000A2   7401         MOV     A,#0x1
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   E4           CLR     A
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   7426         MOV     A,#0x26
   \   0000AC   F0           MOVX    @DPTR,A
   \   0000AD   A3           INC     DPTR
   \   0000AE   E4           CLR     A
   \   0000AF   F0           MOVX    @DPTR,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   F0           MOVX    @DPTR,A
   \                     ??main_10:
   \   0000B2   7401         MOV     A,#0x1
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   78..         MOV     R0,#?V0
   \   0000B9   12....       LCALL   ?L_MOV_X
   \   0000BC   85....       MOV     ?V4,?V0
   \   0000BF   85....       MOV     ?V5,?V1
   \   0000C2   85....       MOV     ?V6,?V2
   \   0000C5   85....       MOV     ?V7,?V3
   \   0000C8   90....       MOV     DPTR,#__Constant_ffffffff
   \   0000CB   78..         MOV     R0,#?V4
   \   0000CD   12....       LCALL   ?L_ADD_X
   \   0000D0   7401         MOV     A,#0x1
   \   0000D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D5   78..         MOV     R0,#?V4
   \   0000D7   12....       LCALL   ?L_MOV_TO_X
   \   0000DA   E5..         MOV     A,?V0
   \   0000DC   45..         ORL     A,?V1
   \   0000DE   45..         ORL     A,?V2
   \   0000E0   45..         ORL     A,?V3
   \   0000E2   70CE         JNZ     ??main_10
    186          
    187                  HalUARTUnInitISR();
   \   0000E4   758600       MOV     0x86,#0x0
   \   0000E7   C2AA         CLR     0xa8.2
   \   0000E9   C28B         CLR     0x88.3
   \   0000EB   539AFB       ANL     0x9a,#0xfb
   \   0000EE   C2E9         CLR     0xe8.1
    188                }
    189                magicByte = SB_STACK_VALUE;
   \                     ??main_7:
   \   0000F0   90....       MOV     DPTR,#magicByte
   \   0000F3   74CD         MOV     A,#-0x33
   \   0000F5   F0           MOVX    @DPTR,A
    190          
    191                // Simulate a reset for the Application code by an absolute jump to location 0x2000.
    192                asm("LJMP 0x2000\n");
   \   0000F6   022000       LJMP 0x2000
    193                HAL_SYSTEM_RESET();
   \   0000F9   C2AF         CLR     0xa8.7
   \   0000FB   75C9AB       MOV     0xc9,#-0x55
   \   0000FE   75C95B       MOV     0xc9,#0x5b
   \                     ??main_11:
   \   000101   80FE         SJMP    ??main_11
    194              }
    195            }
    196          
    197            sblExec();
   \                     ??main_3:
   \   000103   75..00       MOV     ?V0,#0x0
   \   000106   75..00       MOV     ?V1,#0x0
   \   000109   75..00       MOV     ?V2,#0x0
   \   00010C   75..00       MOV     ?V3,#0x0
   \   00010F   90....       MOV     DPTR,#znpCfg1
   \   000112   E0           MOVX    A,@DPTR
   \   000113   701B         JNZ     ??main_12
   \   000115   D2AA         SETB    0xa8.2
   \   000117   D2AF         SETB    0xa8.7
   \   000119                ; Setup parameters for call to function sbReportState
   \                     ??main_13:
   \   000119   7905         MOV     R1,#0x5
   \   00011B   12....       LCALL   sbReportState
   \                     ??main_14:
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   7003         JNZ     ??main_15
   \   000121                ; Setup parameters for call to function sbUartPoll
   \   000121   12....       LCALL   sbUartPoll
   \                     ??main_15:
   \   000124                ; Setup parameters for call to function sbExec
   \   000124   12....       LCALL   sbExec
   \   000127   E9           MOV     A,R1
   \   000128   F8           MOV     R0,A
   \   000129   7409         MOV     A,#0x9
   \   00012B   68           XRL     A,R0
   \   00012C   7009         JNZ     ??main_16
   \   00012E                ; Setup parameters for call to function sbReportState
   \   00012E   80E9         SJMP    ??main_13
   \                     ??main_12:
   \   000130                ; Setup parameters for call to function vddWait
   \   000130   794E         MOV     R1,#0x4e
   \   000132   12....       LCALL   vddWait
   \   000135   80ED         SJMP    ??main_15
   \                     ??main_16:
   \   000137   7401         MOV     A,#0x1
   \   000139   68           XRL     A,R0
   \   00013A   70E2         JNZ     ??main_14
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   7017         JNZ     ??main_17
   \                     ??main_18:
   \   00013F                ; Setup parameters for call to function sbUartPoll
   \   00013F   12....       LCALL   sbUartPoll
   \   000142   90....       MOV     DPTR,#__Constant_1
   \   000145   78..         MOV     R0,#?V0
   \   000147   12....       LCALL   ?L_ADD_X
   \   00014A   90....       MOV     DPTR,#__Constant_40000
   \   00014D   78..         MOV     R0,#?V0
   \   00014F   12....       LCALL   ?UL_GE_X
   \   000152   50EB         JNC     ??main_18
   \   000154   C2AA         CLR     0xa8.2
    198            HAL_SYSTEM_RESET();
   \                     ??main_17:
   \   000156   C2AF         CLR     0xa8.7
   \   000158   75C9AB       MOV     0xc9,#-0x55
   \   00015B   75C95B       MOV     0xc9,#0x5b
   \                     ??main_19:
   \   00015E   80FE         SJMP    ??main_19
   \   000160                REQUIRE SLEEPSTA
   \   000160                REQUIRE _A_IEN0
   \   000160                REQUIRE WDCTL
   \   000160                REQUIRE U0CSR
   \   000160                REQUIRE _A_TCON
   \   000160                REQUIRE IEN2
   \   000160                REQUIRE _A_IRCON2
   \   000160                REQUIRE _A_U1CSR
    199          }
    200          
    201          /**************************************************************************************************
    202           * @fn          vddWait
    203           *
    204           * @brief       Loop waiting for 16 reads of the Vdd over the requested limit.
    205           *
    206           * input parameters
    207           *
    208           * @param       vdd - Vdd level to wait for.
    209           *
    210           * output parameters
    211           *
    212           * None.
    213           *
    214           * @return      None.
    215           **************************************************************************************************
    216           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    217          void vddWait(uint8 vdd)
   \                     vddWait:
    218          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    219            static uint8 max_verified_voltage = 0;
    220            uint8 cnt = 16;
   \   000004   7810         MOV     R0,#0x10
    221          
    222            if (vdd <= max_verified_voltage)
   \   000006   90....       MOV     DPTR,#??max_verified_voltage
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   C3           CLR     C
   \   00000B   99           SUBB    A,R1
   \   00000C   5015         JNC     ??vddWait_0
    223            {
    224              return;
    225            }
    226            
    227            do {
    228              do {
    229                ADCCON3 = 0x0F;
   \                     ??vddWait_1:
   \   00000E   75B60F       MOV     0xb6,#0xf
    230                while (!(ADCCON1 & 0x80));
   \                     ??vddWait_2:
   \   000011   E5B4         MOV     A,0xb4
   \   000013   A2E7         MOV     C,0xE0 /* A   */.7
   \   000015   50FA         JNC     ??vddWait_2
    231              } while (ADCH < vdd);
   \   000017   E5BB         MOV     A,0xbb
   \   000019   C3           CLR     C
   \   00001A   99           SUBB    A,R1
   \   00001B   40F1         JC      ??vddWait_1
    232            } while (--cnt);
   \   00001D   18           DEC     R0
   \   00001E   E8           MOV     A,R0
   \   00001F   70ED         JNZ     ??vddWait_1
    233          
    234            max_verified_voltage = vdd;
   \   000021   E9           MOV     A,R1
   \   000022   F0           MOVX    @DPTR,A
    235          }
   \                     ??vddWait_0:
   \   000023   02....       LJMP    ?Subroutine1
   \   000026                REQUIRE ADCCON3
   \   000026                REQUIRE ADCCON1
   \   000026                REQUIRE ADCH

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??max_verified_voltage:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    236          
    237          /**************************************************************************************************
    238           * @fn          sblInit
    239           *
    240           * @brief       Initialization for SBL.
    241           *
    242           * input parameters
    243           *
    244           * None.
    245           *
    246           * output parameters
    247           *
    248           * None.
    249           *
    250           * @return      None.
    251           **************************************************************************************************
    252           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    253          static void sblInit(void)
   \                     sblInit:
    254          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    255            HAL_BOARD_INIT();
   \   000004   53BEFB       ANL     0xbe,#0xfb
   \                     ??sblInit_0:
   \   000007   E59D         MOV     A,0x9d
   \   000009   A2E6         MOV     C,0xE0 /* A   */.6
   \   00000B   50FA         JNC     ??sblInit_0
   \   00000D   00           NOP
   \   00000E   78F8         MOV     R0,#-0x8
   \   000010   7901         MOV     R1,#0x1
   \                     ??sblInit_1:
   \   000012   00           NOP
   \   000013   12....       LCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_16:
   \   000016   70FA         JNZ     ??sblInit_1
   \   000018   75C680       MOV     0xc6,#-0x80
   \                     ??sblInit_2:
   \   00001B   7480         MOV     A,#-0x80
   \   00001D   659E         XRL     A,0x9e
   \   00001F   70FA         JNZ     ??sblInit_2
   \   000021   43BE04       ORL     0xbe,#0x4
   \   000024   906270       MOV     DPTR,#0x6270
   \   000027   7408         MOV     A,#0x8
   \   000029   F0           MOVX    @DPTR,A
    256            vddWait(VDD_MIN_RUN);
   \   00002A                ; Setup parameters for call to function vddWait
   \   00002A   794A         MOV     R1,#0x4a
   \   00002C   12....       LCALL   vddWait
    257            magicByte = SB_MAGIC_VALUE;
   \   00002F   90....       MOV     DPTR,#magicByte
   \   000032   74F5         MOV     A,#-0xb
   \   000034   F0           MOVX    @DPTR,A
    258          
    259            /* This is in place of calling HalDmaInit() which would require init of the other 4 DMA
    260             * descriptors in addition to just Channel 0.
    261             */
    262            HAL_DMA_SET_ADDR_DESC0(&dmaCh0);
   \   000035   74..         MOV     A,#(dmaCh0 >> 8) & 0xff
   \   000037   F5D5         MOV     0xd5,A
   \   000039   75D4..       MOV     0xd4,#dmaCh0 & 0xff
    263          
    264          #if defined CC2530_MK
    265            znpCfg1 = ZNP_CFG1_SPI;
    266          #else
    267            znpCfg1 = P2_0;
   \   00003C   A2A0         MOV     C,0xa0.0
   \   00003E   E4           CLR     A
   \   00003F   33           RLC     A
   \   000040   90....       MOV     DPTR,#znpCfg1
   \   000043   F0           MOVX    @DPTR,A
    268          #endif
    269            if (znpCfg1 == ZNP_CFG1_SPI)
   \   000044   A2E0         MOV     C,0xE0 /* A   */.0
   \   000046   5029         JNC     ??sblInit_3
    270            {
    271              SRDY_CLR();
   \   000048   D284         SETB    0x80.4
    272          
    273              // Select general purpose on I/O pins.
    274              P0SEL &= ~(NP_RDYIn_BIT);      // P0.3 MRDY - GPIO
   \   00004A   53F3F7       ANL     0xf3,#0xf7
    275              P0SEL &= ~(NP_RDYOut_BIT);     // P0.4 SRDY - GPIO
   \   00004D   53F3EF       ANL     0xf3,#0xef
    276          
    277              // Select GPIO direction.
    278              P0DIR &= ~NP_RDYIn_BIT;        // P0.3 MRDY - IN
   \   000050   53FDF7       ANL     0xfd,#0xf7
    279              P0DIR |= NP_RDYOut_BIT;        // P0.4 SRDY - OUT
   \   000053   43FD10       ORL     0xfd,#0x10
    280          
    281              P0INP &= ~NP_RDYIn_BIT;        // Pullup/down enable of MRDY input.
   \   000056   538FF7       ANL     0x8f,#0xf7
    282              P2INP &= ~BV(5);               // Pullup all P0 inputs.
   \   000059   53F7DF       ANL     0xf7,#0xdf
    283          
    284              HalUARTInitSPI();
   \   00005C   43FC20       ORL     0xfc,#0x20
   \   00005F   43F102       ORL     0xf1,#0x2
   \   000062   53F5DF       ANL     0xf5,#0xdf
   \   000065   75F820       MOV     0xf8,#0x20
   \   000068   43F4F0       ORL     0xf4,#0xf0
   \   00006B   D2FE         SETB    0xf8.6
   \   00006D   D2AB         SETB    0xa8.3
    285            }
   \   00006F   8028         SJMP    ??sblInit_4
    286            else
    287            {
    288              halUARTCfg_t uartConfig;
    289          
    290              HalUARTInitISR();
   \                     ??sblInit_3:
   \   000071   53FF3F       ANL     0xff,#0x3f
   \   000074   85FFFF       MOV     0xff,0xff
   \   000077   53F1FE       ANL     0xf1,#0xfe
   \   00007A   43F30C       ORL     0xf3,#0xc
   \   00007D   53F2F3       ANL     0xf2,#0xf3
   \   000080   758680       MOV     0x86,#-0x80
   \   000083   75C480       MOV     0xc4,#-0x80
    291              uartConfig.configured           = TRUE;
    292              uartConfig.baudRate             = HAL_UART_BR_115200;
    293              uartConfig.flowControl          = FALSE;
    294              uartConfig.flowControlThreshold = 0;  // CC2530 by #define - see hal_board_cfg.h
    295              uartConfig.rx.maxBufSize        = 0;  // CC2530 by #define - see hal_board_cfg.h
    296              uartConfig.tx.maxBufSize        = 0;  // CC2530 by #define - see hal_board_cfg.h
    297              uartConfig.idleTimeout          = 0;  // CC2530 by #define - see hal_board_cfg.h
    298              uartConfig.intEnable            = TRUE;
    299              uartConfig.callBackFunc         = NULL;
    300              HalUARTOpenISR(&uartConfig);
   \   000086   90....       MOV     DPTR,#isrCfg + 263
   \   000089   E4           CLR     A
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   A3           INC     DPTR
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   75C2D8       MOV     0xc2,#-0x28
   \   000090   75C50B       MOV     0xc5,#0xb
   \   000093   75C402       MOV     0xc4,#0x2
   \   000096   438640       ORL     0x86,#0x40
    301            }
    302          }
   \                     ??sblInit_4:
   \   000099   80..         SJMP    ?Subroutine1
   \   00009B                REQUIRE SLEEPCMD
   \   00009B                REQUIRE SLEEPSTA
   \   00009B                REQUIRE CLKCONCMD
   \   00009B                REQUIRE CLKCONSTA
   \   00009B                REQUIRE DMA0CFGH
   \   00009B                REQUIRE DMA0CFGL
   \   00009B                REQUIRE _A_P2
   \   00009B                REQUIRE _A_P0
   \   00009B                REQUIRE P0SEL
   \   00009B                REQUIRE P0DIR
   \   00009B                REQUIRE P0INP
   \   00009B                REQUIRE P2INP
   \   00009B                REQUIRE U0BAUD
   \   00009B                REQUIRE U0GCR
   \   00009B                REQUIRE U0UCR
   \   00009B                REQUIRE U0CSR
   \   00009B                REQUIRE P2DIR
   \   00009B                REQUIRE PERCFG
   \   00009B                REQUIRE ADCCFG
   \   00009B                REQUIRE U1GCR
   \   00009B                REQUIRE P2SEL
   \   00009B                REQUIRE _A_U1CSR
   \   00009B                REQUIRE P1SEL
   \   00009B                REQUIRE _A_IEN0
    303          
    304          /**************************************************************************************************
    305           * @fn          sblExec
    306           *
    307           * @brief       Infinite SBL execute loop that returns upon receiving a code enable.
    308           *
    309           * input parameters
    310           *
    311           * None.
    312           *
    313           * output parameters
    314           *
    315           * None.
    316           *
    317           * @return      None.
    318           **************************************************************************************************
    319           */
    320          static void sblExec(void)
    321          {
    322          
    323            uint32 dlyCnt = 0;
    324            uint8 sbExec_rc;
    325          
    326            if (znpCfg1 == ZNP_CFG1_UART)
    327            {
    328              URX0IE = 1;
    329              HAL_ENABLE_INTERRUPTS();
    330          	
    331              sbReportState(SB_STATE_BOOTLOADER_ACTIVE);
    332            }
    333            else
    334            {
    335              /* For preventing an unknown delay after sending SB_FORCE_BOOT and before being able to send
    336                 SB_HANDSHAKE_CMD, this call was moved to the processing of SB_HANDSHAKE_CMD, which has an
    337                 associated response (SB_FORCE_BOOT does not have any response). This change was required
    338                 for the bootloader to work on the Alektrona gateway reference board. It was verified only
    339                 with UART, so at the moment the behavior for SPI is left unchanged. */
    340              vddWait(VDD_MIN_NV);
    341            }
    342          
    343            while (1)
    344            {
    345              if (znpCfg1 == ZNP_CFG1_UART)
    346              {
    347                sbUartPoll();
    348              }
    349          
    350              sbExec_rc = sbExec();
    351              if (sbExec_rc == SB_CMND_ENABLE_STATE_REPORTING)
    352              {
    353                sbReportState(SB_STATE_BOOTLOADER_ACTIVE);
    354              }
    355              else if (sbExec_rc == SB_CMND_ENABLED_CMD_OK)
    356              {
    357                // Delay to allow the SB_ENABLE_CMD response to be flushed.
    358                if (znpCfg1 == ZNP_CFG1_UART)
    359                {
    360                  for (dlyCnt = 0; dlyCnt < 0x40000; dlyCnt++)
    361                  {
    362                    sbUartPoll();
    363                  }
    364          
    365                  URX0IE = 0;
    366                }
    367                break;
    368              }
    369            }
    370          }
    371          
    372          /**************************************************************************************************
    373           * @fn          sbUartPoll
    374           *
    375           * @brief       Executes TX in poll mode.
    376           *
    377           * input parameters
    378           *
    379           * None.
    380           *
    381           * output parameters
    382           *
    383           * None.
    384           *
    385           * @return      none
    386           **************************************************************************************************
    387           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    388          void sbUartPoll(void)
   \                     sbUartPoll:
    389          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8003         SJMP    ??sbUartPoll_0
    390            while(UTX0IF)
    391            {
    392              halUartTxIsr();
   \                     ??sbUartPoll_1:
   \   000002                ; Setup parameters for call to function halUartTxIsr
   \   000002   12....       LCALL   halUartTxIsr
    393            }
   \                     ??sbUartPoll_0:
   \   000005   A2E9         MOV     C,0xe8.1
   \   000007   40F9         JC      ??sbUartPoll_1
    394          }
   \   000009   22           RET
   \   00000A                REQUIRE _A_IRCON2
    395          
    396          /**************************************************************************************************
    397           * @fn          sblIsUartTxPending
    398           *
    399           * @brief       Check TX queue status.
    400           *
    401           * input parameters
    402           *
    403           * None.
    404           *
    405           * output parameters
    406           *
    407           * None.
    408           *
    409           * @return TRUE - there are bytes pending TX, FALSE - no bytes are pendig TX
    410           **************************************************************************************************
    411           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    412          bool sblIsUartTxPending(void)
   \                     sblIsUartTxPending:
    413          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    414            return (isrCfg.txHead != isrCfg.txTail);
   \   000004   90....       MOV     DPTR,#isrCfg + 260
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   68           XRL     A,R0
   \   00000C   6004         JZ      ??sblIsUartTxPending_0
   \   00000E   7901         MOV     R1,#0x1
   \   000010   8002         SJMP    ??sblIsUartTxPending_1
   \                     ??sblIsUartTxPending_0:
   \   000012   7900         MOV     R1,#0x0
   \                     ??sblIsUartTxPending_1:
   \   000014                REQUIRE ?Subroutine1
   \   000014                ; // Fall through to label ?Subroutine1
    415          }
    416          
    417          /**************************************************************************************************
    418           * @fn          sblWait
    419           *
    420           * @brief       A timed-out wait loop that exits early upon receiving a force code/sbl byte.
    421           *
    422           * input parameters
    423           *
    424           * None.
    425           *
    426           * output parameters
    427           *
    428           * None.
    429           *
    430           * @return      TRUE to run the code image, FALSE to run the SBL.
    431           **************************************************************************************************
    432           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    433          static uint8 sblWait(uint16 sbl_wait_time)
   \                     sblWait:
    434          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    435            uint32 dlyCnt;
    436            uint8 rtrn = FALSE;
   \   00000A   7E00         MOV     R6,#0x0
    437            uint8 sbExec_rc;
    438            uint8 ch;
    439          
    440            if (znpCfg1 == ZNP_CFG1_SPI)
   \   00000C   90....       MOV     DPTR,#znpCfg1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6401         XRL     A,#0x1
   \   000012   706C         JNZ     ??sblWait_0
    441            {
    442              // Slave signals ready for read by setting its ready flag first.
    443              SRDY_SET();
   \   000014   C284         CLR     0x80.4
    444              // Flag to sbRx() to poll for 1 Rx byte instead of blocking read until MRDY_CLR.
    445              spiPoll = TRUE;
   \   000016   90....       MOV     DPTR,#spiPoll
   \   000019   7401         MOV     A,#0x1
   \   00001B   F0           MOVX    @DPTR,A
    446              dlyCnt = 0x38;  // About 50 msecs.
   \   00001C   75..38       MOV     ?V0,#0x38
   \   00001F   8E..         MOV     ?V1,R6
   \   000021   8E..         MOV     ?V2,R6
   \   000023   8E..         MOV     ?V3,R6
    447            }
    448            else
    449            {
    450              URX0IE = 1;
    451              HAL_ENABLE_INTERRUPTS();
    452              dlyCnt = (uint32)0x7332 * sbl_wait_time; //0x7332 gives about 1 second
    453          
    454              sbReportState(SB_STATE_WAITING);
    455            }
    456          
    457            while (1)
    458            {
    459              if (znpCfg1 == ZNP_CFG1_UART)
    460              {
    461                sbUartPoll();
    462          
    463                sbExec_rc = sbExec();
    464                if (sbExec_rc == SB_CMND_ENABLE_STATE_REPORTING)
    465                {
    466                  sbReportState(SB_STATE_WAITING);
    467                }
    468                else if (sbExec_rc == SB_CMND_FORCE_RUN)
    469                {
    470                  dlyCnt = 0;
    471                }
    472                else if ((sbExec_rc != SB_CMND_IDLE) && (sbExec_rc != SB_CMND_UNSUPPORTED))
    473                {
    474                  break;
    475                }
    476              }
    477              else // Note: the SPI implementation was left unchanged, since the new implementation
    478                   // (as implemented for the UART) was not tested with SPI at this time.
    479              {
    480                if (sbRx(&ch, 1))
   \                     ??sblWait_1:
   \   000025                ; Setup parameters for call to function sbRx
   \   000025   7C01         MOV     R4,#0x1
   \   000027   7D00         MOV     R5,#0x0
   \   000029   AA..         MOV     R2,?XSP + 0
   \   00002B   AB..         MOV     R3,?XSP + 1
   \   00002D   12....       LCALL   sbRx
   \   000030   8B..         MOV     ?V5,R3
   \   000032   EA           MOV     A,R2
   \   000033   45..         ORL     A,?V5
   \   000035   6018         JZ      ??sblWait_2
    481                {
    482                  if (ch == SB_FORCE_BOOT)
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6410         XRL     A,#0x10
   \   000040   602D         JZ      ??sblWait_3
    483                  {
    484                    break;
    485                  }
    486                  else if (ch == SB_FORCE_RUN)
   \   000042   E0           MOVX    A,@DPTR
   \   000043   64EF         XRL     A,#0xef
   \   000045   7008         JNZ     ??sblWait_2
    487                  {
    488                    dlyCnt = 0;
   \                     ??sblWait_4:
   \   000047   8E..         MOV     ?V0,R6
   \   000049   8E..         MOV     ?V1,R6
   \   00004B   8E..         MOV     ?V2,R6
   \   00004D   8E..         MOV     ?V3,R6
    489                  }
    490                }
    491              }
    492          
    493              if (dlyCnt-- == 0)
   \                     ??sblWait_2:
   \   00004F   85....       MOV     ?V4,?V0
   \   000052   85....       MOV     ?V5,?V1
   \   000055   85....       MOV     ?V6,?V2
   \   000058   85....       MOV     ?V7,?V3
   \   00005B   90....       MOV     DPTR,#__Constant_ffffffff
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?L_ADD_X
   \   000063   E5..         MOV     A,?V4
   \   000065   45..         ORL     A,?V5
   \   000067   45..         ORL     A,?V6
   \   000069   45..         ORL     A,?V7
   \   00006B   7034         JNZ     ??sblWait_5
    494              {
    495                rtrn = TRUE;
   \   00006D   7E01         MOV     R6,#0x1
    496                break;
    497              }
    498            }
    499          
    500            if (znpCfg1 == ZNP_CFG1_SPI)
   \                     ??sblWait_3:
   \   00006F   90....       MOV     DPTR,#znpCfg1
   \   000072   E0           MOVX    A,@DPTR
   \   000073   6401         XRL     A,#0x1
   \   000075   7056         JNZ     ??sblWait_6
    501            {
    502              // Master blocks waiting for slave to clear its ready flag before continuing.
    503              SRDY_CLR();
   \   000077   D284         SETB    0x80.4
    504              // Flag to sbRx() to now block while reading Rx bytes until MRDY_CLR.
    505              spiPoll = FALSE;
   \   000079   90....       MOV     DPTR,#spiPoll
   \   00007C   E4           CLR     A
   \   00007D   F0           MOVX    @DPTR,A
   \   00007E   8051         SJMP    ??sblWait_7
    506            }
   \                     ??sblWait_0:
   \   000080   D2AA         SETB    0xa8.2
   \   000082   D2AF         SETB    0xa8.7
   \   000084   8A..         MOV     ?V0,R2
   \   000086   8B..         MOV     ?V1,R3
   \   000088   E4           CLR     A
   \   000089   F5..         MOV     ?V2,A
   \   00008B   F5..         MOV     ?V3,A
   \   00008D   90....       MOV     DPTR,#__Constant_7332
   \   000090   78..         MOV     R0,#?V4
   \   000092   12....       LCALL   ?L_MOV_X
   \   000095   78..         MOV     R0,#?V0
   \   000097   79..         MOV     R1,#?V4
   \   000099   12....       LCALL   ?L_MUL
   \   00009C                ; Setup parameters for call to function sbReportState
   \   00009C   7906         MOV     R1,#0x6
   \   00009E   12....       LCALL   sbReportState
   \                     ??sblWait_5:
   \   0000A1   90....       MOV     DPTR,#znpCfg1
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   6003         JZ      $+5
   \   0000A7   02....       LJMP    ??sblWait_1
   \   0000AA                ; Setup parameters for call to function sbUartPoll
   \   0000AA   12....       LCALL   sbUartPoll
   \   0000AD                ; Setup parameters for call to function sbExec
   \   0000AD   12....       LCALL   sbExec
   \   0000B0   E9           MOV     A,R1
   \   0000B1   F8           MOV     R0,A
   \   0000B2   7409         MOV     A,#0x9
   \   0000B4   68           XRL     A,R0
   \   0000B5   7007         JNZ     ??sblWait_8
   \   0000B7                ; Setup parameters for call to function sbReportState
   \   0000B7   7906         MOV     R1,#0x6
   \   0000B9   12....       LCALL   sbReportState
   \   0000BC   8091         SJMP    ??sblWait_2
   \                     ??sblWait_8:
   \   0000BE   7407         MOV     A,#0x7
   \   0000C0   68           XRL     A,R0
   \   0000C1   6084         JZ      ??sblWait_4
   \   0000C3   E8           MOV     A,R0
   \   0000C4   6089         JZ      ??sblWait_2
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   68           XRL     A,R0
   \   0000C9   70A4         JNZ     ??sblWait_3
   \   0000CB   8082         SJMP    ??sblWait_2
    507            else
    508            {
    509              HAL_DISABLE_INTERRUPTS();
   \                     ??sblWait_6:
   \   0000CD   C2AF         CLR     0xa8.7
    510              URX0IE = 0;
   \   0000CF   C2AA         CLR     0xa8.2
    511            }
    512          
    513            return rtrn;
   \                     ??sblWait_7:
   \   0000D1   EE           MOV     A,R6
   \   0000D2   F9           MOV     R1,A
   \   0000D3   7401         MOV     A,#0x1
   \   0000D5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D8   7F08         MOV     R7,#0x8
   \   0000DA   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   0000DD                REQUIRE _A_P0
   \   0000DD                REQUIRE _A_IEN0
    514          }
    515          
    516          /**************************************************************************************************
    517           * @fn          sbRx
    518           *
    519           * @brief       Serial Boot loader read API that makes the low-level read according to RPC mode.
    520           *
    521           * input parameters
    522           *
    523           * @param       buf - Pointer to a buffer to fill with up to 'len' bytes.
    524           * @param       len - Maximum count of bytes to fill into the 'buf'.
    525           *
    526           *
    527           * output parameters
    528           *
    529           * None.
    530           *
    531           * @return      The count of the number of bytes filled into the 'buf'.
    532           **************************************************************************************************
    533           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    534          uint16 sbRx(uint8 *buf, uint16 len)
   \                     sbRx:
    535          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    536            if (znpCfg1 == ZNP_CFG1_UART)
   \   000004   90....       MOV     DPTR,#znpCfg1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7005         JNZ     ??sbRx_0
    537            {
    538              return HalUARTReadISR(buf, len);
   \   00000A                ; Setup parameters for call to function HalUARTReadISR
   \   00000A   12....       LCALL   HalUARTReadISR
   \   00000D   801E         SJMP    ??sbRx_1
    539            }
    540            else
    541            {
    542              if (spiPoll)
   \                     ??sbRx_0:
   \   00000F   90....       MOV     DPTR,#spiPoll
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6015         JZ      ??sbRx_2
    543              {
    544                if (URXxIF)
   \   000015   A28F         MOV     C,0x88.7
   \   000017   500B         JNC     ??sbRx_3
    545                {
    546                  *buf = UxDBUF;
   \   000019   E5F9         MOV     A,0xf9
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   F0           MOVX    @DPTR,A
    547                  return 1;
   \   000020   7A01         MOV     R2,#0x1
   \   000022   8002         SJMP    ??sbRx_4
    548                }
    549                else
    550                {
    551                  return 0;
   \                     ??sbRx_3:
   \   000024   7A00         MOV     R2,#0x0
   \                     ??sbRx_4:
   \   000026   7B00         MOV     R3,#0x0
   \   000028   8003         SJMP    ??sbRx_1
    552                }
    553              }
    554              else
    555              {
    556                return HalUARTReadSPI(buf, len);
   \                     ??sbRx_2:
   \   00002A                ; Setup parameters for call to function HalUARTReadSPI
   \   00002A   12....       LCALL   HalUARTReadSPI
    557              }
    558            }
   \                     ??sbRx_1:
   \   00002D   02....       LJMP    ?Subroutine1
   \   000030                REQUIRE _A_TCON
   \   000030                REQUIRE U1DBUF
    559          }
    560          
    561          /**************************************************************************************************
    562           * @fn          sbTx
    563           *
    564           * @brief       Serial Boot loader write API that makes the low-level write according to RPC mode.
    565           *
    566           * input parameters
    567           *
    568           * @param       buf - Pointer to a buffer of 'len' bytes to write to the serial transport.
    569           * @param       len - Length in bytes of the 'buf'.
    570           *
    571           *
    572           * output parameters
    573           *
    574           * None.
    575           *
    576           * @return      The count of the number of bytes written from the 'buf'.
    577           **************************************************************************************************
    578           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    579          uint16 sbTx(uint8 *buf, uint16 len)
   \                     sbTx:
    580          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    581            if (znpCfg1 == ZNP_CFG1_UART)
   \   000004   90....       MOV     DPTR,#znpCfg1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7005         JNZ     ??sbTx_0
    582            {
    583              return HalUARTWriteISR(buf, len);
   \   00000A                ; Setup parameters for call to function HalUARTWriteISR
   \   00000A   12....       LCALL   HalUARTWriteISR
   \   00000D   8003         SJMP    ??sbTx_1
    584            }
    585            else
    586            {
    587              return HalUARTWriteSPI(buf, len);
   \                     ??sbTx_0:
   \   00000F                ; Setup parameters for call to function HalUARTWriteSPI
   \   00000F   12....       LCALL   HalUARTWriteSPI
    588            }
   \                     ??sbTx_1:
   \   000012   02....       LJMP    ?Subroutine1
    589          }
    590          
    591          /**************************************************************************************************
    592           * @fn          URXx/UTXx_VECTOR
    593           *
    594           * @brief       Intercept the USART0 ISR's here and consume locally if in boot loader, or forward
    595           *              to a valid run-code image.
    596           *
    597           * input parameters
    598           *
    599           * None.
    600           *
    601           * output parameters
    602           *
    603           * None.
    604           *
    605           * @return      None.
    606           **************************************************************************************************
    607           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    608          HAL_ISR_FUNCTION( halUart0RxIsr, URX0_VECTOR )
   \                     halUart0RxIsr:
    609          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    610            if (magicByte == SB_STACK_VALUE)
   \   000007   90....       MOV     DPTR,#magicByte
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   64CD         XRL     A,#0xcd
   \   00000D   7005         JNZ     ??halUart0RxIsr_0
    611            {
    612              void (*rxIsr)(void);
    613              rxIsr = (void (*)(void))0x2013;
    614              rxIsr();
   \   00000F                ; Setup parameters for indirect call
   \   00000F   122013       LCALL   0x2013
   \   000012   802A         SJMP    ??halUart0RxIsr_1
    615            }
    616            else if (magicByte == SB_MAGIC_VALUE)
   \                     ??halUart0RxIsr_0:
   \   000014   E0           MOVX    A,@DPTR
   \   000015   64F5         XRL     A,#0xf5
   \   000017   7024         JNZ     ??halUart0RxIsr_2
    617            {
    618              halUartRxIsr();
   \   000019   E5C1         MOV     A,0xc1+0x0
   \   00001B   C28B         CLR     0x88.3
   \   00001D   C0E0         PUSH    A
   \   00001F   90....       MOV     DPTR,#isrCfg + 129
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   74..         MOV     A,#isrCfg & 0xff
   \   000026   28           ADD     A,R0
   \   000027   F582         MOV     DPL,A
   \   000029   E4           CLR     A
   \   00002A   34..         ADDC    A,#(isrCfg >> 8) & 0xff
   \   00002C   F583         MOV     DPH,A
   \   00002E   D0E0         POP     A
   \   000030   F0           MOVX    @DPTR,A
   \   000031   90....       MOV     DPTR,#isrCfg + 129
   \   000034   12....       LCALL   ?Subroutine4
    619            }
   \                     ??CrossCallReturnLabel_5:
   \   000037   4005         JC      ??halUart0RxIsr_1
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
   \   00003B   8001         SJMP    ??halUart0RxIsr_1
    620            else
    621            {
    622              asm("NOP");  // Not expected.
   \                     ??halUart0RxIsr_2:
   \   00003D   00           NOP
    623            }
    624          }
   \                     ??halUart0RxIsr_1:
   \   00003E                REQUIRE ?Subroutine2
   \   00003E                REQUIRE U0DBUF
   \   00003E                REQUIRE _A_TCON
   \   00003E                ; // Fall through to label ?Subroutine2

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?INTERRUPT_LEAVE_XSP
    625          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    626          HAL_ISR_FUNCTION( halUart0TxIsr, UTX0_VECTOR )
   \                     halUart0TxIsr:
    627          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    628            if (magicByte == SB_STACK_VALUE)
   \   000007   90....       MOV     DPTR,#magicByte
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   64CD         XRL     A,#0xcd
   \   00000D   7005         JNZ     ??halUart0TxIsr_0
    629            {
    630              void (*txIsr)(void);
    631              txIsr = (void (*)(void))0x203B;
    632              txIsr();
   \   00000F                ; Setup parameters for indirect call
   \   00000F   12203B       LCALL   0x203b
   \   000012   800B         SJMP    ??halUart0TxIsr_1
    633            }
    634            else if (magicByte == SB_MAGIC_VALUE)
   \                     ??halUart0TxIsr_0:
   \   000014   E0           MOVX    A,@DPTR
   \   000015   64F5         XRL     A,#0xf5
   \   000017   7005         JNZ     ??halUart0TxIsr_2
    635            {
    636              halUartTxIsr();
   \   000019                ; Setup parameters for call to function halUartTxIsr
   \   000019   12....       LCALL   halUartTxIsr
   \   00001C   8001         SJMP    ??halUart0TxIsr_1
    637            }
    638            else
    639            {
    640              asm("NOP");  // Not expected.
   \                     ??halUart0TxIsr_2:
   \   00001E   00           NOP
    641            }
    642          }
   \                     ??halUart0TxIsr_1:
   \   00001F   80..         SJMP    ?Subroutine2

   \                                 In  segment INTVEC, offset 0x13, root
   \                     `??halUart0RxIsr::??INTVEC 19`:
   \   000013   02....       LJMP       (halUart0RxIsr)

   \                                 In  segment INTVEC, offset 0x3b, root
   \                     `??halUart0TxIsr::??INTVEC 59`:
   \   00003B   02....       LJMP       (halUart0TxIsr)

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_a5690303:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_a5690303>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_a5690303>`:
   \   000000   030369A5     DD 2775122691

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_a5690202:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_a5690202>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_a5690202>`:
   \   000000   020269A5     DD 2775122434

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_ffffffff:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_ffffffff>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_ffffffff>`:
   \   000000   FFFFFFFF     DD 4294967295

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_1:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_1>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_1>`:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_40000:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_40000>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_40000>`:
   \   000000   00000400     DD 262144

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_7332:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_7332>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_7332>`:
   \   000000   32730000     DD 29490
    643          
    644          /**************************************************************************************************
    645          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1      8   HalUARTReadISR
      1      8   HalUARTReadSPI
      1      9   HalUARTWriteISR
      1      8   HalUARTWriteSPI
      1     14   halUart0RxIsr
      0     14   halUart0TxIsr
        0     14   -> halUartTxIsr
      2     14   halUartTxIsr
      0      5   main
        0      5   -> sbExec
        0      5   -> sbImgValid
        0      5   -> sbReportState
        0      5   -> sbUartPoll
        0      5   -> sblInit
        0      5   -> sblIsUartTxPending
        0      5   -> sblWait
        0      5   -> vddWait
      3     16   sbRx
        2      0   -> HalUARTReadISR
        2      0   -> HalUARTReadSPI
      2      0   sbTx
        2      0   -> HalUARTWriteISR
        2      0   -> HalUARTWriteSPI
      0     16   sbUartPoll
        0      0   -> halUartTxIsr
      2      5   sblInit
        2      0   -> vddWait
      2      5   sblIsUartTxPending
      0     21   sblWait
        0     16   -> sbExec
        0     16   -> sbReportState
        0     16   -> sbRx
        0     16   -> sbUartPoll
      2      5   vddWait


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Initializer for __Constant_1>
       4  ?<Initializer for __Constant_40000>
       4  ?<Initializer for __Constant_7332>
       4  ?<Initializer for __Constant_a5690202>
       4  ?<Initializer for __Constant_a5690303>
       4  ?<Initializer for __Constant_ffffffff>
       5  ??Subroutine10_0
      10  ??Subroutine11_0
       4  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine2
       9  ?Subroutine3
       7  ?Subroutine4
      13  ?Subroutine5
      11  ?Subroutine6
       1  ?Subroutine7
       4  ?Subroutine8
      11  ?Subroutine9
       1  ADCCFG
       1  ADCCON1
       1  ADCCON3
       1  ADCH
       1  CLKCONCMD
       1  CLKCONSTA
       1  DMA0CFGH
       1  DMA0CFGL
      62  HalUARTReadISR
     130  HalUARTReadSPI
     130  HalUARTWriteISR
     201  HalUARTWriteSPI
       1  IEN2
       1  P0DIR
       1  P0INP
       1  P0SEL
       1  P1SEL
       1  P2DIR
       1  P2INP
       1  P2SEL
       1  PERCFG
       1  SLEEPCMD
       1  SLEEPSTA
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR
       1  U0UCR
       1  U1DBUF
       1  U1GCR
       1  WDCTL
       1  _A_IEN0
       1  _A_IRCON2
       1  _A_P0
       1  _A_P2
       1  _A_TCON
       1  _A_U1CSR
       4  __Constant_1
       4  __Constant_40000
       4  __Constant_7332
       4  __Constant_a5690202
       4  __Constant_a5690303
       4  __Constant_ffffffff
       1  boot_image_lockbits
       8  dmaCh0
      62  halUart0RxIsr
       3  halUart0RxIsr::??INTVEC 19
      33  halUart0TxIsr
       3  halUart0TxIsr::??INTVEC 59
      42  halUartTxIsr
     265  isrCfg
       1  magicByte
     352  main
       1  max_verified_voltage
      48  sbRx
       1  sbStateReportingEnabled
      21  sbTx
      10  sbUartPoll
     155  sblInit
      20  sblIsUartTxPending
     221  sblWait
     260  spiCfg
       1  spiPoll
      38  vddWait
       1  znpCfg1

 
     6 bytes in segment INTVEC
     1 byte  in segment LOCKBITS
 1 610 bytes in segment NEAR_CODE
     1 byte  in segment SB_MAGIC_SPACE
    33 bytes in segment SFR_AN
    24 bytes in segment XDATA_I
    24 bytes in segment XDATA_ID
   537 bytes in segment XDATA_Z
 
 1 611 bytes of CODE  memory (+ 30 bytes shared)
     0 bytes of DATA  memory (+ 33 bytes shared)
   538 bytes of XDATA memory (+ 24 bytes shared)

Errors: none
Warnings: 1
