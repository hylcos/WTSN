###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                17/Feb/2016  14:01:40
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf04\mac_tx.c
#    Command line       =  
#        -f "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "E:\Sensordinges\Z-Stack
#        Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00008000 -DZDAPP_CONFIG_PAN_ID=0x0EEE
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440 "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack
#        Mesh 1.0.0\Components\mac\low_level\srf04\mac_tx.c" -D NWK_AUTO_POLL
#        -D HOLD_AUTO_START -D POWER_SAVING -D NV_INIT -D
#        DEVICE_LOGICAL_TYPE=ZG_DEVICETYPE_ENDDEVICE -lC
#        "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\List\" -lA
#        "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\List\"
#        --diag_suppress Pe001,Pa010,Pe1665 -o "E:\Sensordinges\Z-Stack Mesh
#        1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\Obj\" -e
#        --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\" -I
#        "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\Source\" -I
#        "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Oh --require_prototypes
#    List file          =  
#        E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\List\mac_tx.lst
#    Object file        =  
#        E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\Obj\mac_tx.r51
#
###############################################################################

E:\Sensordinges\Z-Stack Mesh 1.0.0\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf04\mac_tx.c
      1          /**************************************************************************************************
      2            Filename:       mac_tx.c
      3            Revised:        $Date: 2014-05-16 10:22:59 -0700 (Fri, 16 May 2014) $
      4            Revision:       $Revision: 38564 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_defs.h"
     48          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe1
   \   unsigned char volatile __sfr RFST
   \                     RFST:
   \   000000                DS 1
     49          #include "hal_mac_cfg.h"
     50          
     51          /* high-level */
     52          #include "mac_spec.h"
     53          #include "mac_pib.h"
     54          
     55          /* exported low-level */
     56          #include "mac_low_level.h"
     57          
     58          /* low-level specific */
     59          #include "mac_tx.h"
     60          #include "mac_backoff_timer.h"
     61          #include "mac_rx.h"
     62          #include "mac_rx_onoff.h"
     63          #include "mac_radio.h"
     64          #include "mac_sleep.h"
     65          
     66          /* target specific */
     67          #include "mac_radio_defs.h"
     68          
     69          /* debug */
     70          #include "mac_assert.h"
     71          
     72          #ifdef ACK_DONE_ISR_WORKAROUND
     73          typedef struct macTimer_s
     74          {
     75            struct macTimer_s     *pNext;                     /* next timer in queue */
     76            int32                 backoff;                    /* timer expiration count */
     77            void                  (*pFunc)(uint8 parameter);  /* timer callback function */
     78            uint8                 parameter;                  /* callback function parameter */
     79          } macTimer_t;
     80          
     81          extern void macTimer(macTimer_t *pTimer, uint32 backoffs);
     82          extern void macTimerCancel(macTimer_t *pTimer);
     83          #endif /* ACK_DONE_ISR_WROKAROUND */
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86           *                                            Defines
     87           * ------------------------------------------------------------------------------------------------
     88           */
     89          #define MFR_LEN                   MAC_FCS_FIELD_LEN
     90          #define PREPENDED_BYTE_LEN        1
     91          
     92          #ifdef ACK_DONE_ISR_WORKAROUND
     93            #define ACK_TX_TIMEOUT_BACKOFFS   14 
     94          #endif /* ACK_DONE_ISR_WROKAROUND */
     95          
     96          
     97          /* ------------------------------------------------------------------------------------------------
     98           *                                         Global Constants
     99           * ------------------------------------------------------------------------------------------------
    100           */
    101          
    102          /*
    103           *  This is the time, in backoffs, required to set up a slotted transmit.
    104           *  It is exported to high level so that code can schedule enough time
    105           *  for slotted transmits.
    106           *
    107           *  A default is provided if a value is not specified.  If the default
    108           *  is not appropriate, a #define should be added within hal_mac_cfg.h.
    109           */
    110          #ifndef HAL_MAC_TX_SLOTTED_DELAY
    111          #define HAL_MAC_TX_SLOTTED_DELAY    3
    112          #endif

   \                                 In  segment XDATA_ROM_C, align 1
    113          uint8 const macTxSlottedDelay = HAL_MAC_TX_SLOTTED_DELAY;
   \                     macTxSlottedDelay:
   \   000000   03           DB 3
    114          
    115          
    116          /* ------------------------------------------------------------------------------------------------
    117           *                                         Global Variables
    118           * ------------------------------------------------------------------------------------------------
    119           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    120          uint8 macTxActive;
   \                     macTxActive:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    121          uint8 macTxType;
   \                     macTxType:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    122          uint8 macTxBe;
   \                     macTxBe:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    123          uint8 macTxCsmaBackoffDelay;
   \                     macTxCsmaBackoffDelay:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    124          uint8 macTxGpInterframeDelay;
   \                     macTxGpInterframeDelay:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    125          
    126          #ifdef ACK_DONE_ISR_WORKAROUND
    127            /* MAC Timer for ACK transmit timeout */
    128            macTimer_t macTxAckIsrTimer;
    129          #endif /* ACK_DONE_ISR_WROKAROUND */
    130          
    131          /* ------------------------------------------------------------------------------------------------
    132           *                                         Local Variables
    133           * ------------------------------------------------------------------------------------------------
    134           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          static uint8 nb;
   \                     nb:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    136          static uint8 txSeqn;
   \                     txSeqn:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    137          static uint8 txAckReq;
   \                     txAckReq:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          static uint8 txRetransmitFlag;
   \                     txRetransmitFlag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    139          
    140          
    141          /* ------------------------------------------------------------------------------------------------
    142           *                                         Local Prototypes
    143           * ------------------------------------------------------------------------------------------------
    144           */
    145          static void txCsmaPrep(void);
    146          #ifdef FEATURE_GREEN_POWER
    147          static void txGreenPowerPrep(void);
    148          #endif
    149          static void txGo(void);
    150          static void txCsmaGo(void);
    151          static void txComplete(uint8 status);
    152          
    153          #ifdef ACK_DONE_ISR_WORKAROUND
    154            static void txAckIsrTimeout(uint8 event);
    155          #endif /* ACK_DONE_ISR_WROKAROUND */
    156          
    157          /**************************************************************************************************
    158           * @fn          macTxInit
    159           *
    160           * @brief       Initialize variables for tx module.
    161           *
    162           * @param       none
    163           *
    164           * @return      none
    165           **************************************************************************************************
    166           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    167          MAC_INTERNAL_API void macTxInit(void)
   \                     macTxInit:
    168          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    169            macTxActive      = MAC_TX_ACTIVE_NO_ACTIVITY;
   \   000004   02....       LJMP    ?Subroutine0 & 0xFFFF
    170            txRetransmitFlag = 0;
    171          
    172          #ifdef ACK_DONE_ISR_WORKAROUND
    173            macTxAckIsrTimer.pFunc = &txAckIsrTimeout;
    174          #endif /* ACK_DONE_ISR_WROKAROUND */
    175          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   90....       MOV     DPTR,#macTxActive
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   90....       MOV     DPTR,#txRetransmitFlag
   \   000008   F0           MOVX    @DPTR,A
   \   000009                REQUIRE ??Subroutine8_0
   \   000009                ; // Fall through to label ??Subroutine8_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    176          
    177          
    178          /**************************************************************************************************
    179           * @fn          macTxHaltCleanup
    180           *
    181           * @brief       -
    182           *
    183           * @param       none
    184           *
    185           * @return      none
    186           **************************************************************************************************
    187           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    188          MAC_INTERNAL_API void macTxHaltCleanup(void)
   \                     macTxHaltCleanup:
    189          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    190            MAC_RADIO_TX_RESET();
   \   000004                ; Setup parameters for call to function macCspTxReset
   \   000004   12....       LCALL   `??macCspTxReset::?relay`; Banked call to: macCspTxReset
    191            macTxInit();
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    192          }
    193          
    194          
    195          /**************************************************************************************************
    196           * @fn          macTxFrame
    197           *
    198           * @brief       Transmit the frame pointed to by pMacDataTx with the specified type.
    199           *              NOTE! It is not legal to call this function from interrupt context.
    200           *
    201           * @param       txType - type of transmit
    202           *
    203           * @return      none
    204           **************************************************************************************************
    205           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    206          MAC_INTERNAL_API void macTxFrame(uint8 txType)
   \                     macTxFrame:
    207          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    208            MAC_ASSERT(!macTxActive);            /* transmit on top of transmit */
   \   000007   90....       MOV     DPTR,#macTxActive
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   6003         JZ      ??macTxFrame_0
   \   00000D                ; Setup parameters for call to function halAssertHandler
   \   00000D   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    209          
    210            /* mark transmit as active */
    211            macTxActive = MAC_TX_ACTIVE_INITIALIZE;
   \                     ??macTxFrame_0:
   \   000010   90....       MOV     DPTR,#macTxActive
   \   000013   7401         MOV     A,#0x1
   \   000015   F0           MOVX    @DPTR,A
    212          
    213            /*
    214             *  The MAC will not enter sleep mode if there is an active transmit.  However, if macSleep() is
    215             *  ever called from interrupt context, it possible to enter sleep state after a transmit is
    216             *  intiated but before macTxActive is set.  To recover from this, the transmit must be aborted
    217             *  and proper notificiation given to high-level.
    218             */
    219            if (macSleepState != MAC_SLEEP_STATE_AWAKE)
   \   000016   90....       MOV     DPTR,#macSleepState
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6005         JZ      ??macTxFrame_1
    220            {
    221              /* notify high-level that transmit had to be aborted */
    222              txComplete(MAC_TX_ABORTED);
   \   00001C                ; Setup parameters for call to function txComplete
   \   00001C   791D         MOV     R1,#0x1d
   \   00001E   02....       LJMP    ??macTxFrame_2 & 0xFFFF
    223          
    224              /* exit from transmit logic */
    225              return;
    226            }
    227          
    228            /* save transmit type */
    229            macTxType = txType;
   \                     ??macTxFrame_1:
   \   000021   EE           MOV     A,R6
   \   000022   90....       MOV     DPTR,#macTxType
   \   000025   F0           MOVX    @DPTR,A
    230          
    231            /*-------------------------------------------------------------------------------
    232             *  Prepare for transmit.
    233             */
    234            if (macTxType == MAC_TX_TYPE_SLOTTED)
   \   000026   6402         XRL     A,#0x2
   \   000028   7005         JNZ     ??macTxFrame_3
    235            {
    236              MAC_RADIO_TX_PREP_SLOTTED();
   \   00002A                ; Setup parameters for call to function macCspTxPrepSlotted
   \   00002A   12....       LCALL   `??macCspTxPrepSlotted::?relay`; Banked call to: macCspTxPrepSlotted
   \   00002D   8068         SJMP    ??macTxFrame_4
    237            }
    238          
    239          #ifdef FEATURE_GREEN_POWER
    240            else if (macTxType == MAC_TX_TYPE_GREEN_POWER)
    241            {
    242              txGreenPowerPrep();
    243            }
    244          #endif /* #ifdef FEATURE_GREEN_POWER */
    245          
    246            else
    247            {
    248              MAC_ASSERT((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) || (macTxType == MAC_TX_TYPE_UNSLOTTED_CSMA));
   \                     ??macTxFrame_3:
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6007         JZ      ??macTxFrame_5
   \   000032   6401         XRL     A,#0x1
   \   000034   6003         JZ      ??macTxFrame_5
   \   000036                ; Setup parameters for call to function halAssertHandler
   \   000036   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    249          
    250              nb = 0;
   \                     ??macTxFrame_5:
   \   000039   90....       MOV     DPTR,#nb
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
    251              macTxBe = (pMacDataTx->internal.txOptions & MAC_TXOPTION_ALT_BE) ? macPib.altBe : macPib.minBe;
   \   00003E   90....       MOV     DPTR,#pMacDataTx
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F8           MOV     R0,A
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C8           XCH     A,R0
   \   000046   240E         ADD     A,#0xe
   \   000048   F582         MOV     DPL,A
   \   00004A   E4           CLR     A
   \   00004B   38           ADDC    A,R0
   \   00004C   F583         MOV     DPH,A
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   5440         ANL     A,#0x40
   \   000051   6005         JZ      ??macTxFrame_6
   \   000053   90....       MOV     DPTR,#macPib + 58
   \   000056   8003         SJMP    ??macTxFrame_7
   \                     ??macTxFrame_6:
   \   000058   90....       MOV     DPTR,#macPib + 28
   \                     ??macTxFrame_7:
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   90....       MOV     DPTR,#macTxBe
   \   00005F   12....       LCALL   ??Subroutine7_0 & 0xFFFF
    252          
    253              if ((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) && (macPib.battLifeExt))
   \                     ??CrossCallReturnLabel_7:
   \   000062   7012         JNZ     ??macTxFrame_8
   \   000064   90....       MOV     DPTR,#macPib + 3
   \   000067   E0           MOVX    A,@DPTR
   \   000068   600C         JZ      ??macTxFrame_8
    254              {
    255                macTxBe = MIN(2, macTxBe);
   \   00006A   90....       MOV     DPTR,#macTxBe
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   C3           CLR     C
   \   00006F   9403         SUBB    A,#0x3
   \   000071   4003         JC      ??macTxFrame_8
   \   000073   7402         MOV     A,#0x2
   \   000075   F0           MOVX    @DPTR,A
    256              }
    257          
    258              txCsmaPrep();
   \                     ??macTxFrame_8:
   \   000076                ; Setup parameters for call to function macRadioRandomByte
   \   000076   12....       LCALL   `??macRadioRandomByte::?relay`; Banked call to: macRadioRandomByte
   \   000079   E9           MOV     A,R1
   \   00007A   F9           MOV     R1,A
   \   00007B   75..01       MOV     ?V0,#0x1
   \   00007E   75..00       MOV     ?V1,#0x0
   \   000081   90....       MOV     DPTR,#macTxBe
   \   000084   E0           MOVX    A,@DPTR
   \   000085   78..         MOV     R0,#?V0
   \   000087   12....       LCALL   ?S_SHL
   \   00008A   12....       LCALL   ?Subroutine4 & 0xFFFF
    259            }
   \                     ??CrossCallReturnLabel_10:
   \   00008D   7005         JNZ     ??macTxFrame_9
   \   00008F                ; Setup parameters for call to function macCspTxPrepCsmaSlotted
   \   00008F   12....       LCALL   `??macCspTxPrepCsmaSlotted::?relay`; Banked call to: macCspTxPrepCsmaSlotted
   \   000092   8003         SJMP    ??macTxFrame_4
   \                     ??macTxFrame_9:
   \   000094                ; Setup parameters for call to function macCspTxPrepCsmaUnslotted
   \   000094   12....       LCALL   `??macCspTxPrepCsmaUnslotted::?relay`; Banked call to: macCspTxPrepCsmaUnslotted
    260          
    261            /*-------------------------------------------------------------------------------
    262             *  Load transmit FIFO unless this is a retransmit.  No need to write
    263             *  the FIFO again in that case.
    264             */
    265            if (!txRetransmitFlag)
   \                     ??macTxFrame_4:
   \   000097   90....       MOV     DPTR,#txRetransmitFlag
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   7062         JNZ     ??macTxFrame_10
    266            {
    267              uint8 * p;
    268              uint8   lenMhrMsdu;
    269          
    270              MAC_ASSERT(pMacDataTx != NULL); /* must have data to transmit */
   \   00009D   90....       MOV     DPTR,#pMacDataTx
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F8           MOV     R0,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F9           MOV     R1,A
   \   0000A5   E8           MOV     A,R0
   \   0000A6   49           ORL     A,R1
   \   0000A7   7003         JNZ     ??macTxFrame_11
   \   0000A9                ; Setup parameters for call to function halAssertHandler
   \   0000A9   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    271          
    272              /* save needed parameters */
    273              txAckReq = MAC_ACK_REQUEST(pMacDataTx->msdu.p);
   \                     ??macTxFrame_11:
   \   0000AC   90....       MOV     DPTR,#pMacDataTx
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   2402         ADD     A,#0x2
   \   0000B2   F8           MOV     R0,A
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   3400         ADDC    A,#0x0
   \   0000B7   F9           MOV     R1,A
   \   0000B8   8882         MOV     DPL,R0
   \   0000BA   8983         MOV     DPH,R1
   \   0000BC   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   5420         ANL     A,#0x20
   \   0000C2   90....       MOV     DPTR,#txAckReq
   \   0000C5   F0           MOVX    @DPTR,A
    274              txSeqn   = MAC_SEQ_NUMBER(pMacDataTx->msdu.p);
   \   0000C6   8882         MOV     DPL,R0
   \   0000C8   8983         MOV     DPH,R1
   \   0000CA   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   90....       MOV     DPTR,#txSeqn
   \   0000D1   F0           MOVX    @DPTR,A
    275          
    276              /* set length of frame (note: use of term msdu is a misnomer, here it's actually mhr + msdu) */
    277              lenMhrMsdu = pMacDataTx->msdu.len;
   \   0000D2   90....       MOV     DPTR,#pMacDataTx
   \   0000D5   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   FA           MOV     R2,A
    278          
    279              /* calling code guarantees an unused prepended byte  */
    280              p = pMacDataTx->msdu.p - PREPENDED_BYTE_LEN;
   \   0000DC   8882         MOV     DPL,R0
   \   0000DE   8983         MOV     DPH,R1
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   24FF         ADD     A,#-0x1
   \   0000E3   F8           MOV     R0,A
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   34FF         ADDC    A,#-0x1
   \   0000E8   F9           MOV     R1,A
   \   0000E9   8882         MOV     DPL,R0
   \   0000EB   8983         MOV     DPH,R1
    281          
    282              /* first byte of buffer is length of MPDU */
    283              *p = lenMhrMsdu + MFR_LEN;
   \   0000ED   7402         MOV     A,#0x2
   \   0000EF   2A           ADD     A,R2
   \   0000F0   F0           MOVX    @DPTR,A
    284          
    285              /*
    286               *  Flush the TX FIFO.  This is necessary in case the previous transmit was never
    287               *  actually sent (e.g. CSMA failed without strobing TXON).  If bytes are written to
    288               *  the FIFO but not transmitted, they remain in the FIFO to be transmitted whenever
    289               *  a strobe of TXON does happen.
    290               */
    291              MAC_RADIO_FLUSH_TX_FIFO();
   \   0000F1   75E1EE       MOV     0xe1,#-0x12
    292          
    293              /* write bytes to FIFO, prepended byte is included, MFR is not (it's generated by hardware) */
    294              MAC_RADIO_WRITE_TX_FIFO(p, PREPENDED_BYTE_LEN + lenMhrMsdu);
   \   0000F4                ; Setup parameters for call to function macMemWriteTxFifo
   \   0000F4   7401         MOV     A,#0x1
   \   0000F6   2A           ADD     A,R2
   \   0000F7   F9           MOV     R1,A
   \   0000F8   AA82         MOV     R2,DPL
   \   0000FA   AB83         MOV     R3,DPH
   \   0000FC   12....       LCALL   `??macMemWriteTxFifo::?relay`; Banked call to: macMemWriteTxFifo
    295            }
    296          
    297            /*-------------------------------------------------------------------------------
    298             *  If not receiving, start the transmit.  If receive is active
    299             *  queue up the transmit.
    300             *
    301             *  Critical sections around the state change prevents any sort of race condition
    302             *  with  macTxStartQueuedFrame().  This guarantees function txGo() will only be
    303             *  called once.
    304             */
    305            {
    306              halIntState_t  s;
    307          
    308              HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macTxFrame_10:
   \   0000FF   A2AF         MOV     C,0xa8.7
   \   000101   E4           CLR     A
   \   000102   33           RLC     A
   \   000103   F8           MOV     R0,A
   \   000104   C2AF         CLR     0xa8.7
    309              if (!macRxActive && !macRxOutgoingAckFlag)
   \   000106   90....       MOV     DPTR,#macRxActive
   \   000109   E0           MOVX    A,@DPTR
   \   00010A   702F         JNZ     ??macTxFrame_12
   \   00010C   90....       MOV     DPTR,#macRxOutgoingAckFlag
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   7029         JNZ     ??macTxFrame_12
    310              {
    311                macTxActive = MAC_TX_ACTIVE_GO;
   \   000112   90....       MOV     DPTR,#macTxActive
   \   000115   12....       LCALL   ?Subroutine3 & 0xFFFF
    312                HAL_EXIT_CRITICAL_SECTION(s);
    313                txGo();
    314              }
   \                     ??CrossCallReturnLabel_0:
   \   000118   7005         JNZ     ??macTxFrame_13
   \   00011A                ; Setup parameters for call to function macCspTxGoSlotted
   \   00011A   12....       LCALL   `??macCspTxGoSlotted::?relay`; Banked call to: macCspTxGoSlotted
   \   00011D   8027         SJMP    ??macTxFrame_14
   \                     ??macTxFrame_13:
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   7014         JNZ     ??macTxFrame_15
   \   000122                ; Setup parameters for call to function macDataTxTimeAvailable
   \   000122   12....       LCALL   `??macDataTxTimeAvailable::?relay`; Banked call to: macDataTxTimeAvailable
   \   000125   E9           MOV     A,R1
   \   000126   F8           MOV     R0,A
   \   000127   90....       MOV     DPTR,#macTxCsmaBackoffDelay
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   C3           CLR     C
   \   00012C   98           SUBB    A,R0
   \   00012D   4007         JC      ??macTxFrame_15
   \   00012F                ; Setup parameters for call to function txComplete
   \   00012F   791C         MOV     R1,#0x1c
   \                     ??macTxFrame_2:
   \   000131   12....       LCALL   `??txComplete::?relay`; Banked call to: txComplete
   \   000134   8010         SJMP    ??macTxFrame_14
   \                     ??macTxFrame_15:
   \   000136                ; Setup parameters for call to function macCspTxGoCsma
   \   000136   12....       LCALL   `??macCspTxGoCsma::?relay`; Banked call to: macCspTxGoCsma
   \   000139   800B         SJMP    ??macTxFrame_14
    315              else
    316              {
    317          #ifdef ACK_DONE_ISR_WORKAROUND
    318                if( macRxOutgoingAckFlag == MAC_RX_FLAG_ACK_REQUEST )
    319                {
    320                  /* Add a timeout for queued frame. This special case timeout will be 
    321                   * invoked when the ack done ISR is not fired even after 
    322                   * ACK_TX_TIMEOUT_BACKOFFS.
    323                   * The ACK_TX_TIMEOUT_BACKOFFS value is empirically used keeping in mind
    324                   * the time for a 127 byte packet to be received over-the-air
    325                   * MAC_A_MAX_PHY_PACKET_SIZE is always set to 127 bytes which is the 
    326                   * maximum size a packet can have.
    327                	 */
    328                  macTimer(&macTxAckIsrTimer, ACK_TX_TIMEOUT_BACKOFFS);        
    329                }
    330          #endif /* ACK_DONE_ISR_WROKAROUND */
    331                
    332                macTxActive = MAC_TX_ACTIVE_QUEUED;
   \                     ??macTxFrame_12:
   \   00013B   90....       MOV     DPTR,#macTxActive
   \   00013E   7402         MOV     A,#0x2
   \   000140   F0           MOVX    @DPTR,A
    333                HAL_EXIT_CRITICAL_SECTION(s);
   \   000141   E8           MOV     A,R0
   \   000142   A2E0         MOV     C,0xE0 /* A   */.0
   \   000144   92AF         MOV     0xa8.7,C
    334              }
    335            }
    336          }
   \                     ??macTxFrame_14:
   \   000146                REQUIRE ?Subroutine1
   \   000146                REQUIRE RFST
   \   000146                REQUIRE _A_IEN0
   \   000146                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E5..         MOV     A,?V0
   \   000002   14           DEC     A
   \   000003   59           ANL     A,R1
   \   000004   90....       MOV     DPTR,#macTxCsmaBackoffDelay
   \   000007                REQUIRE ??Subroutine7_0
   \   000007                ; // Fall through to label ??Subroutine7_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine7_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function macTxFrame
   \   000001   90....       MOV     DPTR,#macTxType
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7483         MOV     A,#-0x7d
   \   000002   F0           MOVX    @DPTR,A
   \   000003   E8           MOV     A,R0
   \   000004   A2E0         MOV     C,0xE0 /* A   */.0
   \   000006   92AF         MOV     0xa8.7,C
   \   000008   9061A4       MOV     DPTR,#0x61a4
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   C2E0         CLR     0xE0 /* A   */.0
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   90....       MOV     DPTR,#macRxOutgoingAckFlag
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   90....       MOV     DPTR,#macTxType
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6402         XRL     A,#0x2
   \   00001A   22           RET
    337          
    338          
    339          /*=================================================================================================
    340           * @fn          txCsmaPrep
    341           *
    342           * @brief       Prepare/initialize for a CSMA transmit.
    343           *
    344           * @param       none
    345           *
    346           * @return      none
    347           *=================================================================================================
    348           */
    349          static void txCsmaPrep(void)
    350          {
    351            macTxCsmaBackoffDelay = macRadioRandomByte() & ((1 << macTxBe) - 1);
    352          
    353            if (macTxType == MAC_TX_TYPE_SLOTTED_CSMA)
    354            {
    355              MAC_RADIO_TX_PREP_CSMA_SLOTTED();
    356            }
    357            else
    358            {
    359              MAC_RADIO_TX_PREP_CSMA_UNSLOTTED();
    360            }
    361          }
    362          
    363          
    364          #ifdef FEATURE_GREEN_POWER
    365          /*=================================================================================================
    366           * @fn          txGreenPowerPrep
    367           *
    368           * @brief       Prepare/initialize for a Green Power transmit.
    369           *
    370           * @param       none
    371           *
    372           * @return      none
    373           *=================================================================================================
    374           */
    375          static void txGreenPowerPrep(void)
    376          {
    377            /* Re-use macTxCsmaBackoffDelay for Green Power number of transmissions */
    378            macTxCsmaBackoffDelay  = pMacDataTx->internal.gpNumOfTx;
    379            macTxGpInterframeDelay = pMacDataTx->internal.gpInterframeDelay;
    380          
    381            if (macTxGpInterframeDelay == 0)
    382            {
    383              macTxGpInterframeDelay = 1;
    384            }
    385          
    386            MAC_RADIO_TX_PREP_GREEN_POWER();
    387          }
    388          #endif /* #ifdef FEATURE_GREEN_POWER */
    389          
    390          
    391          /*=================================================================================================
    392           * @fn          txGo
    393           *
    394           * @brief       Start a transmit going.
    395           *
    396           * @param       none
    397           *
    398           * @return      none
    399           *=================================================================================================
    400           */
    401          static void txGo(void)
    402          {
    403            /*
    404             *  If execution has reached this point, any transmitted ACK has long since completed.  It is
    405             *  possible though that there is still a pending callback.  If so, it is irrelevant and needs to
    406             *  be canceled at this point.
    407             */
    408            MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
    409            macRxOutgoingAckFlag = 0;
    410          
    411            /* based on type of transmit, call the correct "go" functionality */
    412            if (macTxType == MAC_TX_TYPE_SLOTTED)
    413            {
    414              MAC_RADIO_TX_GO_SLOTTED();
    415            }
    416          
    417          #ifdef FEATURE_GREEN_POWER
    418            else if (macTxType == MAC_TX_TYPE_GREEN_POWER)
    419            {
    420              MAC_RADIO_TX_GO_GREEN_POWER();
    421            }
    422          #endif /* #ifdef FEATURE_GREEN_POWER */
    423          
    424            else
    425            {
    426              txCsmaGo();
    427            }
    428          }
    429          
    430          
    431          /*=================================================================================================
    432           * @fn          txCsmaGo
    433           *
    434           * @brief       Start a CSMA transmit going.
    435           *
    436           * @param       none
    437           *
    438           * @return      none
    439           *=================================================================================================
    440           */
    441          static void txCsmaGo(void)
    442          {
    443            if (macTxType == MAC_TX_TYPE_SLOTTED_CSMA)
    444            {
    445              if (macTxCsmaBackoffDelay >= macDataTxTimeAvailable())
    446              {
    447                txComplete(MAC_NO_TIME);
    448                return;
    449              }
    450              MAC_RADIO_TX_GO_SLOTTED_CSMA();
    451            }
    452            else
    453            {
    454              MAC_RADIO_TX_GO_CSMA();
    455            }
    456          }
    457          
    458          
    459          /**************************************************************************************************
    460           * @fn          macTxFrameRetransmit
    461           *
    462           * @brief       Retransmit the last frame.
    463           *
    464           * @param       none
    465           *
    466           * @return      none
    467           **************************************************************************************************
    468           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    469          MAC_INTERNAL_API void macTxFrameRetransmit(void)
   \                     macTxFrameRetransmit:
    470          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    471            txRetransmitFlag = 1;
   \   000004   90....       MOV     DPTR,#txRetransmitFlag
   \   000007   7401         MOV     A,#0x1
   \   000009   12....       LCALL   ??Subroutine7_0 & 0xFFFF
    472          
    473          #if defined ( FEATURE_SYSTEM_STATS )
    474            /* Update Diagnostics counter */
    475            macLowLevelDiags(MAC_DIAGS_TX_UCAST_RETRY);
    476          #endif
    477            
    478            macTxFrame(macTxType);
   \                     ??CrossCallReturnLabel_8:
   \   00000C   F9           MOV     R1,A
   \   00000D   12....       LCALL   `??macTxFrame::?relay`; Banked call to: macTxFrame
    479          }
   \   000010   80..         SJMP    ??Subroutine8_0
    480          
    481          
    482          /**************************************************************************************************
    483           * @fn          macTxStartQueuedFrame
    484           *
    485           * @brief       See if there is a queued frame waiting to transmit.  If so, initiate
    486           *              the transmit now.
    487           *
    488           * @param       none
    489           *
    490           * @return      none
    491           **************************************************************************************************
    492           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    493          MAC_INTERNAL_API void macTxStartQueuedFrame(void)
   \                     macTxStartQueuedFrame:
    494          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    495            halIntState_t  s;
    496          
    497            MAC_ASSERT(!macRxActive && !macRxOutgoingAckFlag); /* queued frames should not transmit in middle of a receive */
   \   000005   90....       MOV     DPTR,#macRxActive
   \   000008   E0           MOVX    A,@DPTR
   \   000009   7006         JNZ     ??macTxStartQueuedFrame_0
   \   00000B   90....       MOV     DPTR,#macRxOutgoingAckFlag
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   6003         JZ      ??macTxStartQueuedFrame_1
   \                     ??macTxStartQueuedFrame_0:
   \   000011                ; Setup parameters for call to function halAssertHandler
   \   000011   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    498          
    499            /*
    500             *  Critical sections around the state change prevents any sort of race condition
    501             *  with macTxFrame().  This guarantees function txGo() will only be be called once.
    502             */
    503            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macTxStartQueuedFrame_1:
   \   000014   A2AF         MOV     C,0xa8.7
   \   000016   E4           CLR     A
   \   000017   33           RLC     A
   \   000018   F8           MOV     R0,A
   \   000019   C2AF         CLR     0xa8.7
    504            if (macTxActive == MAC_TX_ACTIVE_QUEUED)
   \   00001B   90....       MOV     DPTR,#macTxActive
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6402         XRL     A,#0x2
   \   000021   7026         JNZ     ??macTxStartQueuedFrame_2
    505            {
    506              macTxActive = MAC_TX_ACTIVE_GO;
   \   000023   12....       LCALL   ?Subroutine3 & 0xFFFF
    507              HAL_EXIT_CRITICAL_SECTION(s);
    508              txGo();
    509            }
   \                     ??CrossCallReturnLabel_1:
   \   000026   7005         JNZ     ??macTxStartQueuedFrame_3
   \   000028                ; Setup parameters for call to function macCspTxGoSlotted
   \   000028   12....       LCALL   `??macCspTxGoSlotted::?relay`; Banked call to: macCspTxGoSlotted
   \   00002B   8021         SJMP    ??macTxStartQueuedFrame_4
   \                     ??macTxStartQueuedFrame_3:
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   7014         JNZ     ??macTxStartQueuedFrame_5
   \   000030                ; Setup parameters for call to function macDataTxTimeAvailable
   \   000030   12....       LCALL   `??macDataTxTimeAvailable::?relay`; Banked call to: macDataTxTimeAvailable
   \   000033   E9           MOV     A,R1
   \   000034   F8           MOV     R0,A
   \   000035   90....       MOV     DPTR,#macTxCsmaBackoffDelay
   \   000038   E0           MOVX    A,@DPTR
   \   000039   C3           CLR     C
   \   00003A   98           SUBB    A,R0
   \   00003B   4007         JC      ??macTxStartQueuedFrame_5
   \   00003D                ; Setup parameters for call to function txComplete
   \   00003D   791C         MOV     R1,#0x1c
   \   00003F   12....       LCALL   `??txComplete::?relay`; Banked call to: txComplete
   \   000042   800A         SJMP    ??macTxStartQueuedFrame_4
   \                     ??macTxStartQueuedFrame_5:
   \   000044                ; Setup parameters for call to function macCspTxGoCsma
   \   000044   12....       LCALL   `??macCspTxGoCsma::?relay`; Banked call to: macCspTxGoCsma
   \   000047   8005         SJMP    ??macTxStartQueuedFrame_4
    510            else
    511            {
    512              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxStartQueuedFrame_2:
   \   000049   E8           MOV     A,R0
   \   00004A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004C   92AF         MOV     0xa8.7,C
    513            }
    514          }
   \                     ??macTxStartQueuedFrame_4:
   \   00004E   02....       LJMP    ?Subroutine2 & 0xFFFF
   \   000051                REQUIRE _A_IEN0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    515          
    516          
    517          /**************************************************************************************************
    518           * @fn          macTxChannelBusyCallback
    519           *
    520           * @brief       This callback is executed if a CSMA transmit was attempted but the channel
    521           *              was busy.
    522           *
    523           * @param       none
    524           *
    525           * @return      none
    526           **************************************************************************************************
    527           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    528          MAC_INTERNAL_API void macTxChannelBusyCallback(void)
   \                     macTxChannelBusyCallback:
    529          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    530            MAC_ASSERT((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) || (macTxType == MAC_TX_TYPE_UNSLOTTED_CSMA));
   \   000005   90....       MOV     DPTR,#macTxType
   \   000008   E0           MOVX    A,@DPTR
   \   000009   6007         JZ      ??macTxChannelBusyCallback_0
   \   00000B   6401         XRL     A,#0x1
   \   00000D   6003         JZ      ??macTxChannelBusyCallback_0
   \   00000F                ; Setup parameters for call to function halAssertHandler
   \   00000F   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    531          
    532            /* turn off receiver if allowed */
    533            macTxActive = MAC_TX_ACTIVE_CHANNEL_BUSY;
   \                     ??macTxChannelBusyCallback_0:
   \   000012   90....       MOV     DPTR,#macTxActive
   \   000015   7404         MOV     A,#0x4
   \   000017   F0           MOVX    @DPTR,A
    534            macRxOffRequest();
   \   000018                ; Setup parameters for call to function macRxOffRequest
   \   000018   12....       LCALL   `??macRxOffRequest::?relay`; Banked call to: macRxOffRequest
    535          
    536            /*  clear channel assement failed, follow through with CSMA algorithm */
    537            nb++;
   \   00001B   90....       MOV     DPTR,#nb
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   04           INC     A
   \   000020   F0           MOVX    @DPTR,A
    538            if (nb > macPib.maxCsmaBackoffs)
   \   000021   F8           MOV     R0,A
   \   000022   90....       MOV     DPTR,#macPib + 27
   \   000025   E0           MOVX    A,@DPTR
   \   000026   C3           CLR     C
   \   000027   98           SUBB    A,R0
   \   000028   5004         JNC     ??macTxChannelBusyCallback_1
    539            {
    540              txComplete(MAC_CHANNEL_ACCESS_FAILURE);
   \   00002A                ; Setup parameters for call to function txComplete
   \   00002A   79E1         MOV     R1,#-0x1f
   \   00002C   805D         SJMP    ??macTxChannelBusyCallback_2
    541            }
    542            else
    543            {
    544              macTxBe = MIN(macTxBe+1, macPib.maxBe);
   \                     ??macTxChannelBusyCallback_1:
   \   00002E   90....       MOV     DPTR,#macPib + 39
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FC           MOV     R4,A
   \   000033   90....       MOV     DPTR,#macTxBe
   \   000036   E0           MOVX    A,@DPTR
   \   000037   2401         ADD     A,#0x1
   \   000039   FA           MOV     R2,A
   \   00003A   E4           CLR     A
   \   00003B   3400         ADDC    A,#0x0
   \   00003D   FB           MOV     R3,A
   \   00003E   EC           MOV     A,R4
   \   00003F   F8           MOV     R0,A
   \   000040   EA           MOV     A,R2
   \   000041   98           SUBB    A,R0
   \   000042   EB           MOV     A,R3
   \   000043   9400         SUBB    A,#0x0
   \   000045   C3           CLR     C
   \   000046   65D0         XRL     A,PSW
   \   000048   33           RLC     A
   \   000049   5004         JNC     ??macTxChannelBusyCallback_3
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   04           INC     A
   \   00004D   8001         SJMP    ??macTxChannelBusyCallback_4
   \                     ??macTxChannelBusyCallback_3:
   \   00004F   EC           MOV     A,R4
   \                     ??macTxChannelBusyCallback_4:
   \   000050   F0           MOVX    @DPTR,A
    545              txCsmaPrep();
   \   000051                ; Setup parameters for call to function macRadioRandomByte
   \   000051   12....       LCALL   `??macRadioRandomByte::?relay`; Banked call to: macRadioRandomByte
   \   000054   E9           MOV     A,R1
   \   000055   F9           MOV     R1,A
   \   000056   75..01       MOV     ?V0,#0x1
   \   000059   75..00       MOV     ?V1,#0x0
   \   00005C   90....       MOV     DPTR,#macTxBe
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   78..         MOV     R0,#?V0
   \   000062   12....       LCALL   ?S_SHL
   \   000065   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000068   7005         JNZ     ??macTxChannelBusyCallback_5
   \   00006A                ; Setup parameters for call to function macCspTxPrepCsmaSlotted
   \   00006A   12....       LCALL   `??macCspTxPrepCsmaSlotted::?relay`; Banked call to: macCspTxPrepCsmaSlotted
   \   00006D   8003         SJMP    ??macTxChannelBusyCallback_6
   \                     ??macTxChannelBusyCallback_5:
   \   00006F                ; Setup parameters for call to function macCspTxPrepCsmaUnslotted
   \   00006F   12....       LCALL   `??macCspTxPrepCsmaUnslotted::?relay`; Banked call to: macCspTxPrepCsmaUnslotted
    546              macTxActive = MAC_TX_ACTIVE_GO;
   \                     ??macTxChannelBusyCallback_6:
   \   000072   90....       MOV     DPTR,#macTxActive
   \   000075   7483         MOV     A,#-0x7d
   \   000077   12....       LCALL   ??Subroutine7_0 & 0xFFFF
    547              txCsmaGo();
    548            }
   \                     ??CrossCallReturnLabel_9:
   \   00007A   7014         JNZ     ??macTxChannelBusyCallback_7
   \   00007C                ; Setup parameters for call to function macDataTxTimeAvailable
   \   00007C   12....       LCALL   `??macDataTxTimeAvailable::?relay`; Banked call to: macDataTxTimeAvailable
   \   00007F   E9           MOV     A,R1
   \   000080   F8           MOV     R0,A
   \   000081   90....       MOV     DPTR,#macTxCsmaBackoffDelay
   \   000084   E0           MOVX    A,@DPTR
   \   000085   C3           CLR     C
   \   000086   98           SUBB    A,R0
   \   000087   4007         JC      ??macTxChannelBusyCallback_7
   \   000089                ; Setup parameters for call to function txComplete
   \   000089   791C         MOV     R1,#0x1c
   \                     ??macTxChannelBusyCallback_2:
   \   00008B   12....       LCALL   `??txComplete::?relay`; Banked call to: txComplete
   \   00008E   8003         SJMP    ??macTxChannelBusyCallback_8
   \                     ??macTxChannelBusyCallback_7:
   \   000090                ; Setup parameters for call to function macCspTxGoCsma
   \   000090   12....       LCALL   `??macCspTxGoCsma::?relay`; Banked call to: macCspTxGoCsma
    549          }
   \                     ??macTxChannelBusyCallback_8:
   \   000093   02....       LJMP    ?Subroutine1 & 0xFFFF
    550          
    551          
    552          /**************************************************************************************************
    553           * @fn          macTxDoneCallback
    554           *
    555           * @brief       This callback is executed when transmit completes.
    556           *
    557           * @param       none
    558           *
    559           * @return      none
    560           **************************************************************************************************
    561           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    562          MAC_INTERNAL_API void macTxDoneCallback(void)
   \                     macTxDoneCallback:
    563          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    564            halIntState_t  s;
    565          
    566            /*
    567             *  There is a small chance this function could be called twice for a single transmit.
    568             *  To prevent logic from executing twice, the state variable macTxActive is used as
    569             *  a gating mechanism to guarantee single time execution.
    570             */
    571            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    572            if (macTxActive == MAC_TX_ACTIVE_GO)
   \   00000C   90....       MOV     DPTR,#macTxActive
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6483         XRL     A,#0x83
   \   000012   701E         JNZ     ??macTxDoneCallback_0
    573            {
    574              /* see if ACK was requested */
    575              if (!txAckReq)
   \   000014   90....       MOV     DPTR,#txAckReq
   \   000017   E0           MOVX    A,@DPTR
   \   000018   90....       MOV     DPTR,#macTxActive
   \   00001B   700F         JNZ     ??macTxDoneCallback_1
    576              {
    577                macTxActive = MAC_TX_ACTIVE_DONE;
   \   00001D   7485         MOV     A,#-0x7b
   \   00001F   F0           MOVX    @DPTR,A
    578                HAL_EXIT_CRITICAL_SECTION(s);
   \   000020   EE           MOV     A,R6
   \   000021   A2E0         MOV     C,0xE0 /* A   */.0
   \   000023   92AF         MOV     0xa8.7,C
    579          
    580                /* ACK was not requested, transmit is complete */
    581                txComplete(MAC_SUCCESS);
   \   000025                ; Setup parameters for call to function txComplete
   \   000025   7900         MOV     R1,#0x0
   \   000027   12....       LCALL   `??txComplete::?relay`; Banked call to: txComplete
   \   00002A   800B         SJMP    ??macTxDoneCallback_2
    582              }
    583              else
    584              {
    585                /*
    586                 *  ACK was requested - must wait to receive it.  A timer is set
    587                 *  to expire after the timeout duration for waiting for an ACK.
    588                 *  If an ACK is received, the function macTxAckReceived() is called.
    589                 *  If an ACK is not received within the timeout period,
    590                 *  the function macTxAckNotReceivedCallback() is called.
    591                 */
    592                macTxActive = MAC_TX_ACTIVE_LISTEN_FOR_ACK;
   \                     ??macTxDoneCallback_1:
   \   00002C   7486         MOV     A,#-0x7a
   \   00002E   F0           MOVX    @DPTR,A
    593                MAC_RADIO_TX_REQUEST_ACK_TIMEOUT_CALLBACK();
   \   00002F                ; Setup parameters for call to function macCspTxRequestAckTimeoutCallback
   \   00002F   12....       LCALL   `??macCspTxRequestAckTimeoutCallback::?relay`; Banked call to: macCspTxRequestAckTimeoutCallback
    594                HAL_EXIT_CRITICAL_SECTION(s);
    595              }
    596            }
    597            else
    598            {
    599              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxDoneCallback_0:
   \   000032   EE           MOV     A,R6
   \   000033   A2E0         MOV     C,0xE0 /* A   */.0
   \   000035   92AF         MOV     0xa8.7,C
    600            }
    601          }
   \                     ??macTxDoneCallback_2:
   \   000037   80..         SJMP    ?Subroutine2
   \   000039                REQUIRE _A_IEN0
    602          
    603          
    604          /**************************************************************************************************
    605           * @fn          macTxAckReceivedCallback
    606           *
    607           * @brief       This function is called by the receive logic when an ACK is received and
    608           *              transmit logic is listening for an ACK.
    609           *
    610           * @param       seqn        - sequence number of received ACK
    611           * @param       pendingFlag - set if pending flag of ACK is set, cleared otherwise
    612           *
    613           * @return      none
    614           **************************************************************************************************
    615           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    616          MAC_INTERNAL_API void macTxAckReceivedCallback(uint8 seqn, uint8 pendingFlag)
   \                     macTxAckReceivedCallback:
    617          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   \   000007   8A..         MOV     ?V0,R2
    618            halIntState_t  s;
    619          
    620            /* only process if listening for an ACK; critical section prevents race condition problems */
    621            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   33           RLC     A
   \   00000D   FE           MOV     R6,A
   \   00000E   C2AF         CLR     0xa8.7
    622            if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
   \   000010   90....       MOV     DPTR,#macTxActive
   \   000013   E0           MOVX    A,@DPTR
   \   000014   6486         XRL     A,#0x86
   \   000016   7025         JNZ     ??macTxAckReceivedCallback_0
    623            {
    624              macTxActive = MAC_TX_ACTIVE_POST_ACK;
   \   000018   7487         MOV     A,#-0x79
   \   00001A   F0           MOVX    @DPTR,A
    625              MAC_RADIO_TX_CANCEL_ACK_TIMEOUT_CALLBACK();
   \   00001B                ; Setup parameters for call to function macCspTxCancelAckTimeoutCallback
   \   00001B   12....       LCALL   `??macCspTxCancelAckTimeoutCallback::?relay`; Banked call to: macCspTxCancelAckTimeoutCallback
    626              HAL_EXIT_CRITICAL_SECTION(s);
   \   00001E   EE           MOV     A,R6
   \   00001F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000021   92AF         MOV     0xa8.7,C
    627          
    628              /* see if the sequence number of received ACK matches sequence number of packet just sent */
    629              if (seqn == txSeqn)
   \   000023   90....       MOV     DPTR,#txSeqn
   \   000026   E0           MOVX    A,@DPTR
   \   000027   6F           XRL     A,R7
   \   000028   700C         JNZ     ??macTxAckReceivedCallback_1
    630              {
    631                /*
    632                 *  Sequence numbers match so transmit is successful.  Return appropriate
    633                 *  status based on the pending flag of the received ACK.
    634                 */
    635                if (pendingFlag)
   \   00002A   E5..         MOV     A,?V0
   \   00002C   6004         JZ      ??macTxAckReceivedCallback_2
    636                {
    637                  txComplete(MAC_ACK_PENDING);
   \   00002E                ; Setup parameters for call to function txComplete
   \   00002E   791B         MOV     R1,#0x1b
   \   000030   8006         SJMP    ??macTxAckReceivedCallback_3
    638                }
    639                else
    640                {
    641                  txComplete(MAC_SUCCESS);
   \                     ??macTxAckReceivedCallback_2:
   \   000032                ; Setup parameters for call to function txComplete
   \   000032   7900         MOV     R1,#0x0
   \   000034   8002         SJMP    ??macTxAckReceivedCallback_3
    642                }
    643              }
    644              else
    645              {
    646                /* sequence number did not match; per spec, transmit failed at this point */
    647                txComplete(MAC_NO_ACK);
   \                     ??macTxAckReceivedCallback_1:
   \   000036                ; Setup parameters for call to function txComplete
   \   000036   79E9         MOV     R1,#-0x17
   \                     ??macTxAckReceivedCallback_3:
   \   000038   12....       LCALL   `??txComplete::?relay`; Banked call to: txComplete
   \   00003B   8005         SJMP    ??macTxAckReceivedCallback_4
    648              }
    649            }
    650            else
    651            {
    652              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxAckReceivedCallback_0:
   \   00003D   EE           MOV     A,R6
   \   00003E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000040   92AF         MOV     0xa8.7,C
    653            }
    654          }
   \                     ??macTxAckReceivedCallback_4:
   \   000042   02....       LJMP    ?Subroutine1 & 0xFFFF
   \   000045                REQUIRE _A_IEN0
    655          
    656          
    657          /**************************************************************************************************
    658           * @fn          macTxAckNotReceivedCallback
    659           *
    660           * @brief       This function is called by the receive logic when transmit is listening
    661           *              for an ACK but something else is received.  It is also called if the
    662           *              listen-for-ACK timeout is reached.
    663           *
    664           * @brief
    665           *
    666           * @param       none
    667           *
    668           * @return      none
    669           **************************************************************************************************
    670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    671          MAC_INTERNAL_API void macTxAckNotReceivedCallback(void)
   \                     macTxAckNotReceivedCallback:
    672          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    673            halIntState_t  s;
    674          
    675            /* only process if listening for an ACK; critical section prevents race condition problems */
    676            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    677            if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
   \   00000C   90....       MOV     DPTR,#macTxActive
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6486         XRL     A,#0x86
   \   000012   7012         JNZ     ??macTxAckNotReceivedCallback_0
    678            {
    679              macTxActive = MAC_TX_ACTIVE_POST_ACK;
   \   000014   7487         MOV     A,#-0x79
   \   000016   F0           MOVX    @DPTR,A
    680              MAC_RADIO_TX_CANCEL_ACK_TIMEOUT_CALLBACK();
   \   000017                ; Setup parameters for call to function macCspTxCancelAckTimeoutCallback
   \   000017   12....       LCALL   `??macCspTxCancelAckTimeoutCallback::?relay`; Banked call to: macCspTxCancelAckTimeoutCallback
    681              HAL_EXIT_CRITICAL_SECTION(s);
   \   00001A   EE           MOV     A,R6
   \   00001B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001D   92AF         MOV     0xa8.7,C
    682          
    683              /* a non-ACK was received when expecting an ACK, per spec transmit is over at this point */
    684              txComplete(MAC_NO_ACK);
   \   00001F                ; Setup parameters for call to function txComplete
   \   00001F   79E9         MOV     R1,#-0x17
   \   000021   12....       LCALL   `??txComplete::?relay`; Banked call to: txComplete
   \   000024   8005         SJMP    ??macTxAckNotReceivedCallback_1
    685            }
    686            else
    687            {
    688              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxAckNotReceivedCallback_0:
   \   000026   EE           MOV     A,R6
   \   000027   A2E0         MOV     C,0xE0 /* A   */.0
   \   000029   92AF         MOV     0xa8.7,C
    689            }
    690          }
   \                     ??macTxAckNotReceivedCallback_1:
   \   00002B                REQUIRE ?Subroutine2
   \   00002B                REQUIRE _A_IEN0
   \   00002B                ; // Fall through to label ?Subroutine2
    691          
    692          #ifdef ACK_DONE_ISR_WORKAROUND
    693          /*=================================================================================================
    694           * @fn          txAckIsrTimeout
    695           *
    696           * @brief       Timeout for ACK Done ISR interrupt. This would be invoked in case ACK done is not fired within 1 ms
    697           *
    698           * @param       none
    699           *
    700           * @return      none
    701           *=================================================================================================
    702           */
    703          static void txAckIsrTimeout(uint8 event)
    704          {
    705            (void)event;
    706            
    707            if ( macRxOutgoingAckFlag == MAC_RX_FLAG_ACK_REQUEST )
    708            {
    709              MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
    710              macRxOutgoingAckFlag = 0;
    711            
    712              if ( macTxActive == MAC_TX_ACTIVE_QUEUED && !macRxActive )
    713              {
    714                macTxStartQueuedFrame();
    715              }
    716            }
    717          
    718            macTimerCancel(&macTxAckIsrTimer);
    719          }
    720          #endif /* ACK_DONE_ISR_WROKAROUND */
    721          
    722          /*=================================================================================================
    723           * @fn          txComplete
    724           *
    725           * @brief       Transmit has completed.  Perform needed maintenance and return status of
    726           *              the transmit via callback function.
    727           *
    728           * @param       status - status of the transmit that just went out
    729           *
    730           * @return      none
    731           *=================================================================================================
    732           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    733          static void txComplete(uint8 status)
   \                     txComplete:
    734          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    735            /* reset the retransmit flag */
    736            txRetransmitFlag = 0;
   \   000007   90....       MOV     DPTR,#txRetransmitFlag
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
    737          
    738            /* update tx state; turn off receiver if nothing is keeping it on */
    739            macTxActive = MAC_TX_ACTIVE_NO_ACTIVITY;
   \   00000C   90....       MOV     DPTR,#macTxActive
   \   00000F   F0           MOVX    @DPTR,A
    740          
    741            if(macPib.rf4cepowerSavings)
   \   000010   90....       MOV     DPTR,#macPib + 60
   \   000013   E0           MOVX    A,@DPTR
   \   000014   6005         JZ      ??txComplete_0
    742            {
    743              /* mark receive as inactive */
    744              macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
   \   000016   90....       MOV     DPTR,#macRxActive
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
    745            }
    746          
    747            /* turn off receive if allowed */
    748            macRxOffRequest();
   \                     ??txComplete_0:
   \   00001B                ; Setup parameters for call to function macRxOffRequest
   \   00001B   12....       LCALL   `??macRxOffRequest::?relay`; Banked call to: macRxOffRequest
    749          
    750            /* update transmit power in case there was a change */
    751            macRadioUpdateTxPower();
   \   00001E                ; Setup parameters for call to function macRadioUpdateTxPower
   \   00001E   12....       LCALL   `??macRadioUpdateTxPower::?relay`; Banked call to: macRadioUpdateTxPower
    752          
    753            /*
    754             *  Channel cannot change during transmit so update it here.  (Channel *can* change during
    755             *  a receive.  The update function resets receive logic and any partially received
    756             *  frame is purged.)
    757             */
    758            macRadioUpdateChannel();
   \   000021                ; Setup parameters for call to function macRadioUpdateChannel
   \   000021   12....       LCALL   `??macRadioUpdateChannel::?relay`; Banked call to: macRadioUpdateChannel
    759          
    760            /* return status of transmit via callback function */
    761            macTxCompleteCallback(status);
   \   000024                ; Setup parameters for call to function macTxCompleteCallback
   \   000024   EE           MOV     A,R6
   \   000025   F9           MOV     R1,A
   \   000026   12....       LCALL   `??macTxCompleteCallback::?relay`; Banked call to: macTxCompleteCallback
    762          }
   \   000029   80..         SJMP    ?Subroutine2
    763          
    764          
    765          /**************************************************************************************************
    766           * @fn          macTxTimestampCallback
    767           *
    768           * @brief       This callback function records the timestamp into the receive data structure.
    769           *              It should be called as soon as possible after there is a valid timestamp.
    770           *
    771           * @param       none
    772           *
    773           * @return      none
    774           **************************************************************************************************
    775           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    776          MAC_INTERNAL_API void macTxTimestampCallback(void)
   \                     macTxTimestampCallback:
    777          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    778            MAC_ASSERT(pMacDataTx != NULL); /* transmit structure must be there */
   \   000005   90....       MOV     DPTR,#pMacDataTx
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F8           MOV     R0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   49           ORL     A,R1
   \   00000F   7003         JNZ     ??macTxTimestampCallback_0
   \   000011                ; Setup parameters for call to function halAssertHandler
   \   000011   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    779          
    780            pMacDataTx->internal.timestamp  = macBackoffTimerCapture();
   \                     ??macTxTimestampCallback_0:
   \   000014                ; Setup parameters for call to function macBackoffTimerCapture
   \   000014   12....       LCALL   `??macBackoffTimerCapture::?relay`; Banked call to: macBackoffTimerCapture
   \   000017   8A..         MOV     ?V0,R2
   \   000019   8B..         MOV     ?V1,R3
   \   00001B   8C..         MOV     ?V2,R4
   \   00001D   8D..         MOV     ?V3,R5
   \   00001F   90....       MOV     DPTR,#pMacDataTx
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F583         MOV     DPH,A
   \   000028   8882         MOV     DPL,R0
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   78..         MOV     R0,#?V0
   \   000031   12....       LCALL   ?L_MOV_TO_X
    781            pMacDataTx->internal.timestamp2 = MAC_RADIO_TIMER_CAPTURE();
   \   000034                ; Setup parameters for call to function macMcuTimerCapture
   \   000034   12....       LCALL   `??macMcuTimerCapture::?relay`; Banked call to: macMcuTimerCapture
   \   000037   8A..         MOV     ?V0,R2
   \   000039   90....       MOV     DPTR,#pMacDataTx
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   CA           XCH     A,R2
   \   000041   2409         ADD     A,#0x9
   \   000043   F582         MOV     DPL,A
   \   000045   E4           CLR     A
   \   000046   3A           ADDC    A,R2
   \   000047   F583         MOV     DPH,A
   \   000049   E5..         MOV     A,?V0
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   EB           MOV     A,R3
   \   00004E   F0           MOVX    @DPTR,A
    782          }
   \   00004F   7F04         MOV     R7,#0x4
   \   000051   02....       LJMP    ?BANKED_LEAVE_XDATA
    783          
    784          
    785          /**************************************************************************************************
    786           * @fn          macTxCollisionWithRxCallback
    787           *
    788           * @brief       Function called if transmit strobed on top of a receive.
    789           *
    790           * @param       none
    791           *
    792           * @return      none
    793           **************************************************************************************************
    794           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    795          MAC_INTERNAL_API void macTxCollisionWithRxCallback(void)
   \                     macTxCollisionWithRxCallback:
    796          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    797            macRxHaltCleanup();
   \   000004                ; Setup parameters for call to function macRxHaltCleanup
   \   000004   12....       LCALL   `??macRxHaltCleanup::?relay`; Banked call to: macRxHaltCleanup
    798          }
   \   000007   02....       LJMP    ??Subroutine8_0 & 0xFFFF

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxHaltCleanup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxHaltCleanup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxFrame::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxFrame

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxFrameRetransmit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxFrameRetransmit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxStartQueuedFrame::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxStartQueuedFrame

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxChannelBusyCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxChannelBusyCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxDoneCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxDoneCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxAckReceivedCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxAckReceivedCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxAckNotReceivedCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxAckNotReceivedCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??txComplete::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    txComplete

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxTimestampCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxTimestampCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macTxCollisionWithRxCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macTxCollisionWithRxCallback
    799          
    800          
    801          /**************************************************************************************************
    802           *                                  Compile Time Integrity Checks
    803           **************************************************************************************************
    804           */
    805          #if (MAC_TX_ACTIVE_NO_ACTIVITY != 0x00)
    806          #error "ERROR! Zero is reserved value of macTxActive. Allows boolean operations, e.g !macTxActive."
    807          #endif
    808          
    809          /**************************************************************************************************
    810          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      9   macTxAckNotReceivedCallback
        0      9   -> macCspTxCancelAckTimeoutCallback
        0      9   -> txComplete
      0     10   macTxAckReceivedCallback
        0     10   -> macCspTxCancelAckTimeoutCallback
        0     10   -> txComplete
      0     10   macTxChannelBusyCallback
        0     10   -> halAssertHandler
        0     10   -> macCspTxGoCsma
        0     10   -> macCspTxPrepCsmaSlotted
        0     10   -> macCspTxPrepCsmaUnslotted
        0     10   -> macDataTxTimeAvailable
        0     10   -> macRadioRandomByte
        0     10   -> macRxOffRequest
        0     10   -> txComplete
      2      0   macTxCollisionWithRxCallback
        2      0   -> macRxHaltCleanup
      0      9   macTxDoneCallback
        0      9   -> macCspTxRequestAckTimeoutCallback
        0      9   -> txComplete
      1     10   macTxFrame
        0     10   -> halAssertHandler
        0     10   -> macCspTxGoCsma
        0     10   -> macCspTxGoSlotted
        0     10   -> macCspTxPrepCsmaSlotted
        0     10   -> macCspTxPrepCsmaUnslotted
        0     10   -> macCspTxPrepSlotted
        0     10   -> macDataTxTimeAvailable
        0     10   -> macMemWriteTxFifo
        0     10   -> macRadioRandomByte
        0     10   -> txComplete
      2      0   macTxFrameRetransmit
        2      0   -> macTxFrame
      2      0   macTxHaltCleanup
        2      0   -> macCspTxReset
      2      0   macTxInit
      0      9   macTxStartQueuedFrame
        0      9   -> halAssertHandler
        0      9   -> macCspTxGoCsma
        0      9   -> macCspTxGoSlotted
        0      9   -> macDataTxTimeAvailable
        0      9   -> txComplete
      0     12   macTxTimestampCallback
        0     12   -> halAssertHandler
        0     12   -> macBackoffTimerCapture
        0     12   -> macMcuTimerCapture
      0     19   txComplete
        0      9   -> macRadioUpdateChannel
        0      9   -> macRadioUpdateTxPower
        0      9   -> macRxOffRequest
        0      9   -> macTxCompleteCallback


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??Subroutine7_0
       7  ??Subroutine8_0
       9  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine2
      27  ?Subroutine3
       7  ?Subroutine4
       6  ?Subroutine5
       9  ?Subroutine6
       1  RFST
       1  _A_IEN0
      43  macTxAckNotReceivedCallback
       6  macTxAckNotReceivedCallback::?relay
      69  macTxAckReceivedCallback
       6  macTxAckReceivedCallback::?relay
       1  macTxActive
       1  macTxBe
     150  macTxChannelBusyCallback
       6  macTxChannelBusyCallback::?relay
      10  macTxCollisionWithRxCallback
       6  macTxCollisionWithRxCallback::?relay
       1  macTxCsmaBackoffDelay
      57  macTxDoneCallback
       6  macTxDoneCallback::?relay
     326  macTxFrame
       6  macTxFrame::?relay
      18  macTxFrameRetransmit
       6  macTxFrameRetransmit::?relay
       1  macTxGpInterframeDelay
      10  macTxHaltCleanup
       6  macTxHaltCleanup::?relay
       7  macTxInit
       6  macTxInit::?relay
       1  macTxSlottedDelay
      81  macTxStartQueuedFrame
       6  macTxStartQueuedFrame::?relay
      84  macTxTimestampCallback
       6  macTxTimestampCallback::?relay
       1  macTxType
       1  nb
       1  txAckReq
      43  txComplete
       6  txComplete::?relay
       1  txRetransmitFlag
       1  txSeqn

 
 979 bytes in segment BANKED_CODE
  72 bytes in segment BANK_RELAYS
   2 bytes in segment SFR_AN
   1 byte  in segment XDATA_ROM_C
   9 bytes in segment XDATA_Z
 
 1 051 bytes of CODE  memory
     1 byte  of CONST memory
     0 bytes of DATA  memory (+ 2 bytes shared)
     9 bytes of XDATA memory

Errors: none
Warnings: none
